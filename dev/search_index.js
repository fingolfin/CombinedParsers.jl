var documenterSearchIndex = {"docs":
[{"location":"lib/internals/iterate/#Iterating-Parsings-1","page":"Iterating Parsings","title":"Iterating Parsings","text":"","category":"section"},{"location":"lib/internals/iterate/#","page":"Iterating Parsings","title":"Iterating Parsings","text":"CombinedParsers._iterate\nCombinedParsers.get","category":"page"},{"location":"lib/internals/iterate/#CombinedParsers._iterate","page":"Iterating Parsings","title":"CombinedParsers._iterate","text":"_iterate(p::ParserWithCaptures, sequence::AbstractString)\n\n\n\n\n\n_iterate(parser, sequence, till, i, states)\n\nNote: i is the index in sequence after parser match according to state (and not the start of the match),  such that start_index(sequence,after,parser,state) returns the start of the matching subsequence, and sequence[start_index(sequence,after,parser,state):prevind(sequence,i)] is the matched subsequence.\n\n\n\n\n\n","category":"function"},{"location":"man/user/#Basics-1","page":"User Guide","title":"Basics","text":"","category":"section"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"The simplest parser matches a String or Char iterator.","category":"page"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"using CombinedParsers\nusing CombinedParsers.Regexp","category":"page"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"parse_a = parser(\"aa\")\n\nparse(parse_a,\"aa\")\n\nparse(parse_a,\"ab\")","category":"page"},{"location":"man/user/#Character-Sets-1","page":"User Guide","title":"Character Sets","text":"","category":"section"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"parse(CharIn('a':'z'),\"c\")\nparse(CharIn(isuppercase),\"A\")\nparse(CharNotIn('a':'z'),\"A\")\nparse(CharNotIn(isuppercase),\"c\")","category":"page"},{"location":"man/user/#Sequence-1","page":"User Guide","title":"Sequence","text":"","category":"section"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"Several parsers can be combined with the Sequence constructor and the * operator. The result_type of a Sequence is the Tuple of the result_types of its parts.","category":"page"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"p = CharIn(isuppercase) * CharIn(islowercase)\n\nparse(p,\"Ab\")","category":"page"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"getindex on a sequence creates a transforming parser selecting from the result of the parsing.","category":"page"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"parse(Sequence(CharIn(isuppercase) * CharIn(islowercase))[2],\"Ab\")","category":"page"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"Sequence keyword argument constructors transform the parsing into a named tuple. If some Sequence arguments are <:Pair{Symbol}, only those are retained in a NamedTuple.","category":"page"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"p = Sequence(first = CharIn(isuppercase), second = CharIn(islowercase))\n\nparse(p,\"Ab\")\n\nparse(Sequence(CharIn(isuppercase), :second => CharIn(islowercase)),\"Ab\")\n","category":"page"},{"location":"man/user/#Either-1","page":"User Guide","title":"Either","text":"","category":"section"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"The | operator and constructor Either try matching the provided parsers in order, accepting the first match, and fails if all parsers fail.","category":"page"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"parse((\"a\"|\"ab\"),\"ab\")","category":"page"},{"location":"man/user/#Repeat-1","page":"User Guide","title":"Repeat","text":"","category":"section"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"The Repeat(p) constructor creates a new parser repeating its argument zero or more times, and by default transforming to Vector{result_type(p)}. Repeating a specified number of times can be achieved with Repeat(p,min=1,max=2), or Repeat(1,p) or Repeat(1,2,p). Equivalently the ^ operator can be used similar as for String, e.g. p^2,  and like in regular expressions p^(+), p^(*).","category":"page"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"parse(join(parser('a')^(*),\" \"),\"a a\")","category":"page"},{"location":"man/user/#Optional-1","page":"User Guide","title":"Optional","text":"","category":"section"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"Similar to Repeat, Optional(p) creates a parser, repeating 0 or 1 times.  The result_type(Optional(p, default=d)) is promote_type (or Union type is type promotion results in Any).","category":"page"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"option = Optional('a') * join(Repeat('b'),\"-\")","category":"page"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"Feedback appreciated:","category":"page"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"option = ( CharIn('a':'z') | missing ) * join(Repeat('b'),\"-\")","category":"page"},{"location":"man/user/#Lazy-repetitions-and-optional-parsers-1","page":"User Guide","title":"Lazy repetitions and optional parsers","text":"","category":"section"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"Repetition and optional parsers are greedy by default, and can be switched to lazy matching by wrapping in Lazy(Repeat(p)).","category":"page"},{"location":"man/user/#Assertions-1","page":"User Guide","title":"Assertions","text":"","category":"section"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"Parsers that do not advance the parsing position can be used to assert conditions during parsing.","category":"page"},{"location":"man/user/#AtStart()-and-AtEnd()-1","page":"User Guide","title":"AtStart() and AtEnd()","text":"","category":"section"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"The AtStart() only succeeds if at the start of the input, and similarly the AtEnd() succeeds only at the end of the input. By default, parse does not need to consume the full input but succeeds with the first match. With AtEnd() the parser can be forced to consume the full input or fail otherwise.","category":"page"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"parse((\"a\"|\"ab\")*AtEnd(),\"ab\")","category":"page"},{"location":"man/user/#Looking-around-1","page":"User Guide","title":"Looking around","text":"","category":"section"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"A Lookaround parser wraps a parser p, succeeds if p matches without advancing the position, and fails if p fails.","category":"page"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"The @re_str macro has a regex parser for lookahead and lookbehind expressions (simplified):","category":"page"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"\n@with_names lookahead=Sequence(\n    2,\n    \"(?\",\n    Either(Sequence(v->PositiveLookahead(v[2]), \"=\", alternation),\n           Sequence(v->NegativeLookahead(v[2]), \"!\", alternation)),\n           Sequence(v->PositiveLookbehind(v[2]), \"<=\", alternation)),\n           Sequence(v->NegativeLookbehind(v[2]), \"<!\", alternation)),\n    \")\")\n\t","category":"page"},{"location":"man/user/#Atomic-groups-1","page":"User Guide","title":"Atomic groups","text":"","category":"section"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"Backtracking of a parser p can be prevented by wrapping in Atomic(Repeat(p)). An atomic parser fails if p fails or if the first successfull parsing with p leads to a failing later in the parsing process.","category":"page"},{"location":"man/user/#","page":"User Guide","title":"User Guide","text":"parse(Either(\"a\",\"ab\",\"ac\")*AtEnd(),\"ab\")\nparse(Atomic(Either(\"a\",\"ab\",\"ac\"))*AtEnd(),\"ab\")","category":"page"},{"location":"user/#User-Manual-1","page":"User Manual","title":"User Manual","text":"","category":"section"},{"location":"user/#Basics-1","page":"User Manual","title":"Basics","text":"","category":"section"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"The simplest parser matches a String or Char iterator.","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"parse_a = parser(\"aa\")\n\nparse(parse_a,\"aa\")\n# \"aa\"\n\nparse(parse_a,\"ab\")\n# ArgumentError: expected re\"a\" in \"ab\" at index 2 (todo!)","category":"page"},{"location":"user/#Character-Sets-1","page":"User Manual","title":"Character Sets","text":"","category":"section"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"parse(CharIn('a':'z'),\"c\") =='c'\nparse(CharIn(isuppercase),\"A\") =='A'\nparse(CharNotIn('a':'z'),\"A\") =='A'\nparse(CharNotIn(isuppercase),\"c\") =='c'","category":"page"},{"location":"user/#Sequence-1","page":"User Manual","title":"Sequence","text":"","category":"section"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"Several parsers can be combined with the Sequence constructor and the * operator. The result_type of a Sequence is the Tuple of the result_types of its parts.","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"parse(Sequence(CharIn(isuppercase) * CharIn(islowercase)),\"Ab\") == ('A','b')\nparse(CharIn(isuppercase) * CharIn(islowercase),\"Ab\") == ('A','b')","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"getindex on a sequence creates a transforming parser selecting from the result of the parsing.","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"Sequence keyword argument constructors transform the parsing into a named tuple.","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"parse(Sequence(first = CharIn(isuppercase), second = CharIn(islowercase)),\"Ab\") == \n\t(first='A',second='b')","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"If some Sequence arguments are <:Pair{Symbol}, only those are retained in a NamedTuple.","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"parse(Sequence(CharIn(isuppercase), :second => CharIn(islowercase)),\"Ab\") == \n\t(second='b',)","category":"page"},{"location":"user/#Either-1","page":"User Manual","title":"Either","text":"","category":"section"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"The | operator and constructor Either try matching the provided parsers in order, accepting the first match, and fails if all parsers fail.","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"parse((\"a\"|\"ab\"),\"ab\")\n# \"a\"","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"Feedback inquiry:","category":"page"},{"location":"user/#Assertions-1","page":"User Manual","title":"Assertions","text":"","category":"section"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"Parsers that do not advance the parsing position can be used to assert conditions during parsing.","category":"page"},{"location":"user/#AtStart()-and-AtEnd()-1","page":"User Manual","title":"AtStart() and AtEnd()","text":"","category":"section"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"The AtStart() only succeeds if at the start of the input, and similarly the AtEnd() succeeds only at the end of the input. By default, parse does not need to consume the full input but succeeds with the first match. With AtEnd() the parser can be forced to consume the full input or fail otherwise.","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"parse((\"a\"|\"ab\")*AtEnd(),\"ab\")\n# \"ab\"","category":"page"},{"location":"user/#Looking-around-1","page":"User Manual","title":"Looking around","text":"","category":"section"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"A Lookaround parser wraps a parser p, succeeds if p matches without advancing the position, and fails if p fails.","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"The @re_str macro has a regex parser for lookahead and lookbehind expressions (simplified):","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"@with_names lookahead=Sequence(\n    2,\n    \"(?\",\n    Either(Sequence(v->PositiveLookahead(v[2]), \"=\", alternation),\n           Sequence(v->NegativeLookahead(v[2]), \"!\", alternation)),\n           Sequence(v->PositiveLookbehind(v[2]), \"<=\", alternation)),\n           Sequence(v->NegativeLookbehind(v[2]), \"<!\", alternation)),\n    \")\");","category":"page"},{"location":"user/#Repeat-1","page":"User Manual","title":"Repeat","text":"","category":"section"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"The Repeat(p) constructor creates a new parser repeating its argument zero or more times, and by default transforming to Vector{result_type(p)}. Repeating a specified number of times can be achieved with Repeat(p,min=1,max=2), or Repeat(1,p) or Repeat(1,2,p). Equivalently the ^ operator can be used similar as for String, e.g. p^2,  and like in regular expressions p^(+), p^(*).","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"parse(join(parser('a')^(*),\" \"),\"a a\") == \n\t['a','a']","category":"page"},{"location":"user/#Optional-1","page":"User Manual","title":"Optional","text":"","category":"section"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"Similar to Repeat, Optional(p) creates a parser, repeating 0 or 1 times.  The result_type(Optional(p, default=d)) is promote_type (or Union type is type promotion results in Any).","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"option = Optional('a') * join(Repeat('b'),\"-\")","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"Feedback appreciated:","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"option = ( CharIn('a':'z') | missing ) * join(Repeat('b'),\"-\")","category":"page"},{"location":"user/#Lazy-repetitions-and-optional-parsers-1","page":"User Manual","title":"Lazy repetitions and optional parsers","text":"","category":"section"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"Repetition and optional parsers are greedy by default, and can be switched to lazy matching by wrapping in Lazy(Repeat(p)).","category":"page"},{"location":"user/#Atomic-groups-1","page":"User Manual","title":"Atomic groups","text":"","category":"section"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"Backtracking of a parser p can be prevented by wrapping in Atomic(Repeat(p)). An atomic parser fails if p fails or if the first successfull parsing with p leads to a failing later in the parsing process.","category":"page"},{"location":"user/#","page":"User Manual","title":"User Manual","text":"parse(Either(\"a\",\"ab\",\"ac\")*AtEnd(),\"ab\") == (\"ab\", AtEnd())\nparse(Atomic(Either(\"a\",\"ab\",\"ac\"))*AtEnd(),\"ab\") # fails","category":"page"},{"location":"lib/internals/types/#Parser-Types-1","page":"Parser Types","title":"Parser Types","text":"","category":"section"},{"location":"lib/internals/types/#Abstract-Types-1","page":"Parser Types","title":"Abstract Types","text":"","category":"section"},{"location":"lib/internals/types/#","page":"Parser Types","title":"Parser Types","text":"CombinedParsers.ParserTypes\nCombinedParsers.AbstractParser\nCombinedParsers.LeafParser\nCombinedParsers.ConstantParser\nCombinedParsers.NIndexParser\nCombinedParsers.WrappedParser\nCombinedParsers.LookAround\nCombinedParsers.Transformation","category":"page"},{"location":"lib/internals/types/#CombinedParsers.ParserTypes","page":"Parser Types","title":"CombinedParsers.ParserTypes","text":"Julia types that can convert(AbstractToken,x). TODO: remove\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/types/#CombinedParsers.AbstractParser","page":"Parser Types","title":"CombinedParsers.AbstractParser","text":"AbstractParser{T} <: AbstractToken{T}\n\nAbstract parser type for parsers returning matches transformed to ::T.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/types/#CombinedParsers.LeafParser","page":"Parser Types","title":"CombinedParsers.LeafParser","text":"LeafParser{T} <: AbstractToken{T}\n\nAbstract parser type for parsers that have no sub-parser. Used for dispatch in deepmap_parser\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/types/#CombinedParsers.ConstantParser","page":"Parser Types","title":"CombinedParsers.ConstantParser","text":"wrapper for stepping with ncodeunit length.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/types/#CombinedParsers.NIndexParser","page":"Parser Types","title":"CombinedParsers.NIndexParser","text":"Abstract type for stepping with previndex/nextindex, accounting for ncodeunit length of chars at point.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/types/#CombinedParsers.WrappedParser","page":"Parser Types","title":"CombinedParsers.WrappedParser","text":"Abstract type for parser wrappers, providing default methods\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/types/#CombinedParsers.LookAround","page":"Parser Types","title":"CombinedParsers.LookAround","text":"Parsers that do not consume any input can inherit this type.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/types/#CombinedParsers.Transformation","page":"Parser Types","title":"CombinedParsers.Transformation","text":"Transformation{T}(transform::Function, p_) where {T}\nmap_at(f::Function, p, a...)\nmap_at(f::Function, Tc::Type, p, a...)\ninstance(Tc::Type, p::ParserTypes, a...)\ninstance(Tc::Type, p::ParserTypes)\nBase.map(f::Function, Tc::Type, p::ParserTypes, a...)\nBase.map(f::Function, p::ParserTypes, a...)\n\nParser transforming result of a wrapped parser.  a... is passed as additional arguments to f (at front .\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/types/#Rewriting-Parsers-1","page":"Parser Types","title":"Rewriting Parsers","text":"","category":"section"},{"location":"lib/internals/types/#","page":"Parser Types","title":"Parser Types","text":"CombinedParsers.deepmap_parser","category":"page"},{"location":"lib/internals/types/#CombinedParsers.deepmap_parser","page":"Parser Types","title":"CombinedParsers.deepmap_parser","text":"deepmap_parser(f::Function,mem::AbstractDict,x::LeafParser,a...)\n\nreturn \n\n    get!(mem,x) do\n        f(x,a...)\n    end\n\n\n\n\n\ndeepmap_parser(f::Function,mem::AbstractDict,x,a...)\n\nPerform a deep transformation of a CombinedParser.\n\nnote: Note\nFor a custom parser P<:AbstractParser with sub-parsers, provide a methoddeepmap_parser(f::Function,mem::AbstractDict,x::P,a...) =\n    get!(mem,x) do\n        ## construct replacement, e.g. if P <: WrappedParser\n        P(deepmap_parser(f,mem,x.parser,a...))\n    end\n\n\n\n\n\ndeepmap_parser(f::Function,x::AbstractParser,a...)\n\nPerform a deep transformation of a CombinedParser. Used for log_names.\n\nCalls deepmap_parser(f,IdDict(),x,a...).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/types/#Regular-Expression-Types-1","page":"Parser Types","title":"Regular Expression Types","text":"","category":"section"},{"location":"lib/internals/types/#","page":"Parser Types","title":"Parser Types","text":"CombinedParsers.Regexp.ParseMatch\nCombinedParsers.Regexp.Capture\nCombinedParsers.Regexp.Backreference\nCombinedParsers.Regexp.Subroutine\nCombinedParsers.Regexp.Conditional\nCombinedParsers.Regexp.DupSubpatternNumbers\nCombinedParsers.Regexp.ParserWithCaptures\nCombinedParsers.Regexp.SequenceWithCaptures","category":"page"},{"location":"lib/internals/types/#CombinedParsers.Regexp.ParseMatch","page":"Parser Types","title":"CombinedParsers.Regexp.ParseMatch","text":"Wrapper type for SequenceWithCaptures, providing getindex and getproperty behavior like RegexMatch.\n\njulia> m = match(re\"(?<a>so)+ (or)\", \"soso or\")\nParseMatch(\"soso or\", a=\"so\", 2=\"or\")\n\njulia> m[:a]\n\"so\"\n\njulia> m[2]\n\"or\"\n\njulia> m.match, m.captures\n(\"soso or\", SubString{String}[\"so\", \"or\"])\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/types/#CombinedParsers.Regexp.Capture","page":"Parser Types","title":"CombinedParsers.Regexp.Capture","text":"Capture a parser result, optionally with a name. index field is initialized when calling ParserWithCaptures on the parser.\n\nParserWithCaptures\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/types/#CombinedParsers.Regexp.Backreference","page":"Parser Types","title":"CombinedParsers.Regexp.Backreference","text":"Backreference(f::Function,index::Integer)\n\nBackreference(f::Function,name::Union{Nothing,Symbol},index::Integer)\n\nBackreference(f::Function,name::AbstractString)\n\nParser matching previously captured sequence, optionally with a name. index field is recursively set when calling 'ParserWithCaptures` on the parser.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/types/#CombinedParsers.Regexp.Subroutine","page":"Parser Types","title":"CombinedParsers.Regexp.Subroutine","text":"Parser matching preceding capture, optionally with a name. index field is recursively set when calling 'ParserWithCaptures` on the parser.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/types/#CombinedParsers.Regexp.Conditional","page":"Parser Types","title":"CombinedParsers.Regexp.Conditional","text":"Conditional parser, _iterate cycles conditionally on _iterate_condition through matches in field yes and no respectively.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/types/#CombinedParsers.Regexp.DupSubpatternNumbers","page":"Parser Types","title":"CombinedParsers.Regexp.DupSubpatternNumbers","text":"Parser wrapper for ParserWithCaptures, setting resetindex=true in `deepmapparser(::typeof(indexedcaptures),...)`.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/types/#CombinedParsers.Regexp.ParserWithCaptures","page":"Parser Types","title":"CombinedParsers.Regexp.ParserWithCaptures","text":"Top level parser supporting regular expression features captures, backreferences and subroutines. Collects subroutines in field subroutines::Vector and  indices of named capture groups in field names::Dict.\n\nnote: Note\nimplicitly called in match\n\nSee also Backreference, Capture, Subroutine\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/types/#CombinedParsers.Regexp.SequenceWithCaptures","page":"Parser Types","title":"CombinedParsers.Regexp.SequenceWithCaptures","text":"SequenceWithCaptures ensapsulates a sequence to be parsed, and parsed captures.\n\nSee also ParserWithCaptures\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/options/#Parsing-Options-1","page":"Parsing Options","title":"Parsing Options","text":"","category":"section"},{"location":"lib/internals/options/#","page":"Parsing Options","title":"Parsing Options","text":"CombinedParsers.Regexp.ParserOptions\nCombinedParsers.Regexp.FilterOptions\nCombinedParsers.Regexp.WithOptions\nCombinedParsers.Regexp.OnOptionsParser","category":"page"},{"location":"lib/internals/options/#CombinedParsers.Regexp.ParserOptions","page":"Parsing Options","title":"CombinedParsers.Regexp.ParserOptions","text":"A wrapper matching the inner parser on with_options(set_flags, unset_flags, sequence).\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/options/#CombinedParsers.Regexp.FilterOptions","page":"Parsing Options","title":"CombinedParsers.Regexp.FilterOptions","text":"Lazy wrapper for a sequence, masking elements in getindex with MatchingNever if any of flags are not set.\n\nTODO: make flags a filter function?\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/options/#CombinedParsers.Regexp.WithOptions","page":"Parsing Options","title":"CombinedParsers.Regexp.WithOptions","text":"A lazy element transformation type (e.g. AbstractString),  getindex wraps elements in with_options(flags,...).\n\nWith parsing options\n\nTODO: make flags a transformation function?\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/options/#CombinedParsers.Regexp.OnOptionsParser","page":"Parsing Options","title":"CombinedParsers.Regexp.OnOptionsParser","text":"Parser wrapper sequence with if_options.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Public-Documentation-1","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Documentation for CombinedParsers.jl's public interface.","category":"page"},{"location":"lib/public/#","page":"Public","title":"Public","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"lib/public/#Public-Interface-1","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"lib/public/#CombinedParsers-1","page":"Public","title":"CombinedParsers","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"CombinedParsers\nparser\nconvert","category":"page"},{"location":"lib/public/#CombinedParsers","page":"Public","title":"CombinedParsers","text":"A package for combining parsers and transforming strings into julia types.\n\nCompose parsers with the functional parser combinator paradigm, utilize Julia's type inferrence for transformations, log conveniently for debugging, and let Julia compile your parser for good performance.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CombinedParsers.parser","page":"Public","title":"CombinedParsers.parser","text":"calls convert(AbstractToken,x).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Base.convert","page":"Public","title":"Base.convert","text":"convert(::Type{AbstractToken},x::Union{AbstractString,Char})\n\nA ConstantParser matching x.\n\n\n\n\n\nconvert(::Type{AbstractToken},x::StepRange{Char,<:Integer})\n\nCharIn matching x.\n\n\n\n\n\nconvert(::Type{AbstractToken},x::Pair{Symbol, P}) where P\n\nA parser labelled with name x.first. Labels are useful in printing and logging.\n\nSee also: @with_names, with_name, log_names\n\n\n\n\n\nconvert(::Type{AbstractToken},constant::Pair{<:ParserTypes})\n\nA parser mapping matches of x.first to constant x.second.\n\nSee also: @map, map_at\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.Regexp-1","page":"Public","title":"CombinedParsers.Regexp","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"CombinedParsers.Regexp\nCombinedParsers.Regexp.@re_str\nCombinedParsers.Regexp.match\nregex_escape","category":"page"},{"location":"lib/public/#CombinedParsers.Regexp","page":"Public","title":"CombinedParsers.Regexp","text":"A regular expression parser transforming a PCRE string to a CombinedParser equivalent to the regular expression.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CombinedParsers.Regexp.@re_str","page":"Public","title":"CombinedParsers.Regexp.@re_str","text":"@re_str(x,flags)\n\nConstruct a ParserWithCaptures from PCRE regex syntax, such as re\"^[a-z]*$\", without interpolation and unescaping (except for quotation mark \" which still has to be escaped).  Plug-in replacement for PCRE string macro @r_str.\n\nThe regex also accepts one or more flags, listed after the ending quote, to change its behaviour:\n\ni enables case-insensitive matching\nm treats the ^ and $ tokens as matching the start and end of individual lines, as opposed to the whole string.\ns allows the . modifier to match newlines.\nx enables \"comment mode\": whitespace is ignored except when escaped with \\, and # is treated as starting a comment.\na disables UCP mode (enables ASCII mode). By default \\B, \\b, \\D, \\d, \\S, \\s, \\W, \\w, etc. match based on Unicode character properties. With this option, these sequences only match ASCII characters.\nxx enables \"extended comment mode\": whitespace in bracket character matchers are ignored.\n\njulia> re\"a|c\"i\n|🗄... Either |> regular expression combinator\n├─ [aA]\n└─ [cC]\n::Char\n\njulia> re\"a+c\"\n🗄 Sequence |> regular expression combinator\n├─ a+  |> Repeat\n└─ c\n::Tuple{Array{Char,1},Char}\n\n\n\n\n\n","category":"macro"},{"location":"lib/public/#Base.match","page":"Public","title":"Base.match","text":"Base.match(parser::ParserTypes,sequence::AbstractString; log=false)\n\nPlug-in replacement for match(::Regex,sequence).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.regex_escape","page":"Public","title":"CombinedParsers.regex_escape","text":"regex_escape(s::AbstractString)\n\nregular expression metacharacters are escaped along with whitespace.\n\nExamples\n\njulia> regex_escape(\"Bang!\")\n\"Bang\\!\"\njulia> regex_escape(\"  ( [ { . ? *\")\n\"\\ \\ \\(\\ \\[\\ \\{\\ \\.\\ \\?\\ \\*\"\njulia> regex_escape(\"/^[a-z0-9_-]{3,16}$/\")\n\"/\\^\\[a\\-z0\\-9_\\-\\]\\{3,16\\}\\$/\"\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Parsing,-Logging-and-Side-Effects-1","page":"Public","title":"Parsing, Logging and Side-Effects","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"parse\ntryparse\nwith_name\n@with_names\nlog_names\nwith_log\ninstrument\nwith_effect","category":"page"},{"location":"lib/public/#Base.parse","page":"Public","title":"Base.parse","text":"parse(parser::ParserTypes, str::AbstractString; log=nothing)\n\nParse a string with a CombinedParser as an instance of result_type(parser).\n\nIf log is a Vector{Symbol}, parser is transformed with log_names(p, log). See also log_names.\n\njulia> using TextParse\n\njulia> p = (\"Number: \"*TextParse.Numeric(Int))[2]\n🗄 Sequence |> map(#31)\n├─ Number\\:\\\n└─ <Int64>\n::Int64\n\n\njulia> parse(p,\"Number: 42\")\n42\n\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Base.tryparse","page":"Public","title":"Base.tryparse","text":"tryparse(parser::ParserTypes, str::AbstractString)\n\nParse a string with a CombinedParser as an instance of result_type(parser).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.with_name","page":"Public","title":"CombinedParsers.with_name","text":"with_name(name::Symbol,x; doc=\"\")\n\nA parser labelled with name. Labels are useful in printing and logging.\n\nSee also: @with_names, with_name, log_names\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.@with_names","page":"Public","title":"CombinedParsers.@with_names","text":"Sets names of parsers within begin/end block to match the variables they are asigned to.\n\nso, for example\n\njulia> @with_names foo = AnyChar()\n.  |> with_name(:foo)\n::Char\n\njulia> parse(log_names(foo),\"ab\")\n   match foo: ab\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\nSee also log_names(parser)\n\n\n\n\n\n","category":"macro"},{"location":"lib/public/#CombinedParsers.log_names","page":"Public","title":"CombinedParsers.log_names","text":"log_names(x,names=true; exclude=nothing)\n\nRebuild parser replacing NamedParser instances with with_log parsers. Log all NamedParser instanses if names==true or name in names and not name in exclude.\n\nSee also: with_log, deepmap_parser\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.with_log","page":"Public","title":"CombinedParsers.with_log","text":"with_log(s::AbstractString,p, delta=5;nomatch=false)\n\nLog matching process of parser p, displaying delta characters left of and right of match.\n\nIf nomatch==true, also log when parser does not match.\n\nSee also: log_names, with_effect\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.with_effect","page":"Public","title":"CombinedParsers.with_effect","text":"with_effect(f::Function,p,a...)\n\nCall f(sequence,before_i,after_i,state,a...) if p matches,  f(sequence,before_i,before_i,nothing,a...) otherwise.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Transformations-1","page":"Public","title":"Transformations","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Base.map\nmap_at\nJoinSubstring\nTransformation\n(!)(::CombinedParsers.AbstractToken)","category":"page"},{"location":"lib/public/#Base.map","page":"Public","title":"Base.map","text":"map(f::Function, p::AbstractToken, a...)\n\nParser matching p, transforming parsing results (x) with function f(x,a...).\n\nSee also: map_at\n\n\n\n\n\nmap(T::Type, p::AbstractToken, a...)\n\nParser matching p, transforming parsing results (x) with constructor T(x,a...).\n\nSee also: map_at\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.map_at","page":"Public","title":"CombinedParsers.map_at","text":"map_at(f::Function, p, a...)\nmap_at(f::Function, Tc::Type, p, a...)\n\nParser transforming result of a wrapped parser.  a... is passed as additional arguments to f.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.JoinSubstring","page":"Public","title":"CombinedParsers.JoinSubstring","text":"JoinSubstring(x)\n(!)(x::AbstractToken)\n\nParser Transformation getting the matched SubString.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Base.:!-Tuple{TextParse.AbstractToken}","page":"Public","title":"Base.:!","text":"(!)(x::AbstractToken)\n\nParser Transformation getting the matched SubString.\n\njulia> parse(Repeat(CharIn(:L)),\"abc123\")\n3-element Array{Char,1}:\n 'a'\n 'b'\n 'c'\n\njulia> parse(!Repeat(CharIn(:L)),\"abc123\")\n\"abc\"\n\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Parser-Constructors-1","page":"Public","title":"Parser Constructors","text":"","category":"section"},{"location":"lib/public/#Character-Matchers-1","page":"Public","title":"Character Matchers","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"AnyChar\nCharIn\nCharNotIn","category":"page"},{"location":"lib/public/#CombinedParsers.AnyChar","page":"Public","title":"CombinedParsers.AnyChar","text":"AnyChar()\n\nParser matching exactly one Char, returning the character.\n\njulia> AnyChar()\nre\".\"\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.CharIn","page":"Public","title":"CombinedParsers.CharIn","text":"CharIn(x)\n\nParser matching exactly one character in x.\n\njulia> a_z = CharIn('a':'z')\nre\"[a-z]\"\n\njulia> parse(a_z, \"a\")\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> ac = CharIn(\"ac\")\nre\"[ac]\"\n\n\njulia> parse(ac, \"c\")\n'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.CharNotIn","page":"Public","title":"CombinedParsers.CharNotIn","text":"CharNotIn(x)\n\nParser matching exactly one character in x.\n\njulia> a_z = CharNotIn('a':'z')\nre\"[^a-z]\"\n\njulia> parse(a_z, \"a\")\nERROR: ArgumentError: no successfull parsing.\nStacktrace:\n [1] parse(::CharNotIn{Tuple{StepRange{Char,Int64}}}, ::String) at /home/gregor/dev/julia/CombinedParsers/src/CombinedParsers.jl:2649\n [2] top-level scope at REPL[19]:1\n\njulia> ac = CharNotIn(\"ac\")\nre\"[^ac]\"\n\n\njulia> parse(ac, \"c\")\nERROR: ArgumentError: no successfull parsing.\nStacktrace:\n [1] parse(::CharNotIn{Array{Char,1}}, ::String) at /home/gregor/dev/julia/CombinedParsers/src/CombinedParsers.jl:2649\n [2] top-level scope at REPL[19]:1\n\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Combining-Parser-1","page":"Public","title":"Combining Parser","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Either\n(|)(::CombinedParsers.ParserTypes, ::CombinedParsers.ParserTypes)\nsEither\nSequence\nsSequence\nAtomic","category":"page"},{"location":"lib/public/#CombinedParsers.Either","page":"Public","title":"CombinedParsers.Either","text":"Either(parsers...)\n\nParser that tries matching the provided parsers in order, accepting the first match, and fails if all parsers fail.\n\njulia> match(r\"a|bc\",\"bc\")\nRegexMatch(\"bc\")\n\njulia> parse(Either(\"a\",\"bc\"),\"bc\")\n\"bc\"\n\njulia> parse(\"a\" | \"bc\",\"bc\")\n\"bc\"\n\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Base.:|-Tuple{Union{Char, Regex, AbstractString, Pair{#s12,#s13} where #s13 where #s12<:Union{Char, Regex, AbstractString, Pair, TextParse.AbstractToken}, TextParse.AbstractToken},Union{Char, Regex, AbstractString, Pair{#s12,#s13} where #s13 where #s12<:Union{Char, Regex, AbstractString, Pair, TextParse.AbstractToken}, TextParse.AbstractToken}}","page":"Public","title":"Base.:|","text":"(|)(x::AbstractToken, y)\n(|)(x, y::AbstractToken)\n(|)(x::AbstractToken, y::AbstractToken)\n\nOperator syntax for sEither(x, y).\n\njulia> 'a' | CharIn(\"AB\") | \"bc\"\n|🗄... Either\n├─ a\n├─ [AB]\n└─ bc\n::Union{Char, SubString}\n\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CombinedParsers.sEither","page":"Public","title":"CombinedParsers.sEither","text":"sEither(x...)\n\nSimplifying Either, flattens nested Eithers, remove Never parsers.\n\njulia> Either('a',CharIn(\"AB\")|\"bc\")\n|🗄... Either\n├─ a\n└─ |🗄... Either\n   ├─ [AB]\n   └─ bc\n::Union{Char, SubString}\n\n\njulia> sEither('a',CharIn(\"AB\")|\"bc\")\n|🗄... Either\n├─ a\n├─ [AB]\n└─ bc\n::Union{Char, SubString}\n\n\nSee also Either\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.Sequence","page":"Public","title":"CombinedParsers.Sequence","text":"Sequence(;kw...)\n\nSequence keyword argument constructors transform the parsing into a named tuple.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.sSequence","page":"Public","title":"CombinedParsers.sSequence","text":"sSequence(x...)\n\nSimplifying Sequence, flatten Sequences, remove Always lookarounds.\n\njulia> Sequence('a',CharIn(\"AB\")*'b')\n🗄 Sequence\n├─ a\n└─ 🗄 Sequence\n   ├─ [AB]\n   └─ b\n::Tuple{Char,Tuple{Char,Char}}\n\n\njulia> sSequence('a',CharIn(\"AB\")*'b')\n🗄 Sequence\n├─ a\n├─ [AB]\n└─ b\n::Tuple{Char,Char,Char}\n\nSee also Sequence\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.Atomic","page":"Public","title":"CombinedParsers.Atomic","text":"Atomic(x)\n\nA parser matching p, and failing when required to backtrack (behaving like an atomic group in regular expressions).\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Repeating-1","page":"Public","title":"Repeating","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Optional\n(|)(::CombinedParsers.AbstractToken{T}, ::Union{T,Missing}) where { T }\nRepeat\nRepeat1\nRepeat_stop\nRepeat_until\nBase.join\nalternate","category":"page"},{"location":"lib/public/#CombinedParsers.Optional","page":"Public","title":"CombinedParsers.Optional","text":"Optional(parser;default=defaultvalue(result_type(parser)))\n\nParser that always succeeds.  If parser succeeds, return result of parser with curser behind match. If parser does not succeed, return default with curser unchanged.\n\njulia> match(r\"a?\",\"b\")\nRegexMatch(\"\")\n\njulia> parse(Optional(\"a\"),\"b\")\n\"\"\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Base.:|-Union{Tuple{T}, Tuple{TextParse.AbstractToken{T},Union{Missing, T}}} where T","page":"Public","title":"Base.:|","text":"(|)(x::AbstractToken{T}, default::Union{T,Missing})\n\nOperator syntax for Optional(x, default=default).\n\njulia> parser(\"abc\") | \"nothing\"\n|🗄... Either\n├─ abc\n└─ nothing\n::SubString\n\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CombinedParsers.Repeat","page":"Public","title":"CombinedParsers.Repeat","text":"Repeat(x)\nRepeat(x; min=0,max=typemax(Int))\nRepeat(min::Integer, x)\nRepeat(min::Integer,max::Integer, x)\n\nParser repeating pattern x min:max times.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.Repeat1","page":"Public","title":"CombinedParsers.Repeat1","text":"Repeat1(x)\n\nParser repeating pattern x one time or more.\n\n\n\n\n\nRepeat1(f::Function,a...)\n\nAbbreviation for map(f,Repeat1(a...)).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.Repeat_stop","page":"Public","title":"CombinedParsers.Repeat_stop","text":"Repeat_stop(p,stop)\n\nRepeat p until stop (NegativeLookahead), not matching stop. Sets cursor before stop. Returns results of p.\n\njulia> p = Repeat_stop(AnyChar(),'b') * AnyChar()\n🗄 Sequence\n├─ 🗄* Sequence |> map(#27) |> Repeat\n│  ├─ (?!🗄)\n│  │  └─ b\n│  └─ .\n└─ .\n::Tuple{Array{Char,1},Char}\n\njulia> parse(p,\"acbX\")\n(['a', 'c'], 'b')\n\nSee also NegativeLookahead\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.Repeat_until","page":"Public","title":"CombinedParsers.Repeat_until","text":"Repeat\\_until(p,until, with_until=false;wrap=identity)\n\nRepeat p until stop (with Repeat_stop). and set point after stop.\n\nReturn a Vector{result_type(p)} if wrap_until==false, otherwise a Tuple{Vector{result_type(p)},result_type(until)}.\n\nTo transform the Repeat_stop(p) parser head, provide a function(::Vector{result_type(p)}) in wrap keyword argument, e.g.\n\njulia> p = Repeat_until(AnyChar(),'b') * AnyChar()\n🗄 Sequence\n├─ 🗄 Sequence |> map(#27)\n│  ├─ 🗄* Sequence |> map(#27) |> Repeat\n│  │  ├─ (?!🗄)\n│  │  │  └─ b\n│  │  └─ .\n│  └─ b\n└─ .\n::Tuple{Array{Char,1},Char}\n\njulia> parse(p,\"acbX\")\n(['a', 'c'], 'X')\n\njulia> parse(Repeat_until(AnyChar(),'b';wrap=JoinSubstring),\"acbX\")\n\"ac\"\n\nSee also NegativeLookahead\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Base.join","page":"Public","title":"Base.join","text":"Base.join(x::Repeat,delim)\n\nParser matching repeated x.parser separated by delim.\n\njulia> parse(join(Repeat(AnyChar()),','),\"a,b,c\")\n3-element Array{Char,1}:\n 'a'\n 'b'\n 'c'\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.alternate","page":"Public","title":"CombinedParsers.alternate","text":"optimized repeated alternations of xdelim, optionally starting/ending with delim. delim is agged as right borders.  delim can be discarded in agg(result,missing,delim).\n\nif agg is nothing, default is to aggregate delim after match is result_type(delim) <: result_type(x), if not missing.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Assertions-1","page":"Public","title":"Assertions","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Always\nNever\nPositiveLookahead\nNegativeLookahead\nPositiveLookbehind\nNegativeLookbehind","category":"page"},{"location":"lib/public/#CombinedParsers.Always","page":"Public","title":"CombinedParsers.Always","text":"Always()\n\nAssertion parser matching always and not consuming any input. Returns Always().\n\njulia> Always()\nre\"\"\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.Never","page":"Public","title":"CombinedParsers.Never","text":"Never()\n\nAssertion parser matching never and not consuming any input.\n\njulia> Never()\n(*FAIL) Never\n::Never\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.PositiveLookahead","page":"Public","title":"CombinedParsers.PositiveLookahead","text":"PositiveLookahead(parser)\n\nParser that succeeds if and only if parser succeeds, but consumes no input. The match is returned. Useful for checks like \"must be followed by parser, but don't consume its match\".\n\njulia> la=PositiveLookahead(\"peek\")\nre\"(?=peek)\"\n\n\njulia> parse(la*AnyChar(),\"peek\")\n(re\"(?=peek)\", 'p')\n\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.NegativeLookahead","page":"Public","title":"CombinedParsers.NegativeLookahead","text":"NegativeLookahead(parser)\n\nParser that succeeds if and only if parser does not succeed, but consumes no input. parser is returned as match. Useful for checks like \"must not be followed by parser, don't consume its match\".\n\njulia> la = NegativeLookahead(\"peek\")\nre\"(?!peek)\"\n\njulia> parse(la*AnyChar(),\"peek\")\nERROR: ArgumentError: no successfull parsing.\nStacktrace:\n [1] parse(::Sequence{Tuple{SubString,Char},Tuple{NegativeLookahead{SubString,CombinedParsers.ConstantParser{4,SubString}},AnyChar}}, ::String) at /home/gregor/dev/julia/CombinedParsers/src/CombinedParsers.jl:2583\n [2] top-level scope at REPL[24]:1\n\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.PositiveLookbehind","page":"Public","title":"CombinedParsers.PositiveLookbehind","text":"PositiveLookbehind(parser)\n\nParser that succeeds if and only if parser succeeds before cursor. Consumes no input. The match is returned. Useful for checks like \"must be preceded by parser, don't consume its match\".\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.NegativeLookbehind","page":"Public","title":"CombinedParsers.NegativeLookbehind","text":"NegativeLookbehind(parser)\n\nParser that succeeds if and only if parser does not succeed before cursor.  Consumes no input. nothing is returned as match. Useful for checks like \"must not be preceded by parser, don't consume its match\".\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Printing-1","page":"Public","title":"Printing","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"regex_string\nCombinedParsers.regex_prefix\nCombinedParsers.regex_inner\nCombinedParsers.regex_suffix\nCombinedParsers.print_constructor\nCombinedParsers.MemoTreeChildren","category":"page"},{"location":"lib/public/#CombinedParsers.regex_string","page":"Public","title":"CombinedParsers.regex_string","text":"regex_string(x::AbstractParser)\n\nregex_prefix(x)*regex_inner(x)*regex_suffix(x)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.regex_prefix","page":"Public","title":"CombinedParsers.regex_prefix","text":"regex_prefix(x)\n\nPrefix printed in parser tree node.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.regex_inner","page":"Public","title":"CombinedParsers.regex_inner","text":"regex_inner(x::AbstractToken)\n\nRegex representation of x. See regex_string\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.regex_suffix","page":"Public","title":"CombinedParsers.regex_suffix","text":"regex_suffix(x)\n\nSuffix printed in parser tree node.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.print_constructor","page":"Public","title":"CombinedParsers.print_constructor","text":"print_constructor(io::IO,x)\n\nPrint constructor pipeline in parser tree node.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.MemoTreeChildren","page":"Public","title":"CombinedParsers.MemoTreeChildren","text":"decurse recursive patterns\n\n\n\n\n\n","category":"type"},{"location":"#CombinedParsers.jl-Documentation-1","page":"Home","title":"CombinedParsers.jl Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A package for combining parsers and transforming strings into julia types.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Compose parsers with the functional parser combinator paradigm, utilize Julia's type inferrence for transformations, log conveniently for debugging, and let Julia compile your parser for good performance.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nCombinedParsers.jl is currently an α release.\tThe first official released is prepared for JuliaCon2020.","category":"page"},{"location":"#Package-Features-1","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Clear syntax integrates grammar and transformations with Julia type inference.\nHigher-order parsers depending on the parsing state allow for not context-free parsers.\nAll valid parsings can be iterated lazily.\nInteroperable with TextParse.jl: existing TextParse.AbstractToken implementations can be used with CombinedParsers. CombinedParsers.AbstractParser provide TextParse.tryparsenext and can be used e.g. in CSV.jl.\nParametric parser and state types enable Julia compiler optimizations.\nCompiled regular expression parsers in pure julia are provided with the re_str macro. CombinedParsers.jl is tested against the PCRE C library testset.\nAbstractTrees.jl interface provides colored and clearly layed out printing in the REPL.\nConvenient logging of the parsing process with NamedParsers and SideeffectParsers.\nCombinedParsers generalize from strings to parsing any type supporting getindex, nextind, prevind methods.","category":"page"},{"location":"#Writing-Parsers-1","page":"Home","title":"Writing Parsers","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"CombinedParsers provides constructors to combine parsers and transform (sub-)parsings arbitrarily with julia syntax. Combinator constructors are discussed in the user manual.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"\n# Julia eval for +-*/ operators\nfunction eval_ops((l,opr))\n    for (op,val) in opr\n        l = eval( Expr(:call, Symbol(op), l, val))\n    end\n    l::Rational{Int}\nend\n\nusing CombinedParsers\nusing TextParse\n\n@with_names begin\n    number = map(Rational{Int}, TextParse.Numeric(Int))\n    factor = Either(number)  # or expression in parenthesis, see push! below\n    divMul = map(eval_ops,\n                 Sequence( factor, Repeat( CharIn(\"*/\"), factor ) ) )\n    addSub = map(eval_ops,\n\t\t divMul * Repeat( CharIn(\"+-\") * divMul ) )\n    parens = Sequence(2, \"(\",addSub,\")\" )\n    push!(factor, parens)\n    expr = (addSub * AtEnd())[1]\nend;\n\nparse(log_names(expr), \"1/((1+2)*4+3*(5*2))\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Is every rational answer ultimately the inverse of a universal question in life?","category":"page"},{"location":"#Package-Guide-1","page":"Home","title":"Package Guide","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The Overview provides a tutorial explaining how to get started using CombinedParsers.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Some examples of packages using Documenter can be found on the Examples page.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"See the Index for the complete list of documented functions and types.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"man/guide.md\",\n    \"man/user.md\",\n    \"man/pcre.md\",\n    \"man/examples.md\",\n    \"man/syntax.md\",\n    \"man/doctests.md\",\n    \"man/hosting.md\",\n    \"man/latex.md\",\n    \"man/contributing.md\",\n]\nDepth = 1","category":"page"},{"location":"#Library-Outline-1","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [ \"lib/public.md\" ]\nDepth = 5","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Internals","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"lib/internals/types.md\", \"lib/internals/iterate.md\"]","category":"page"},{"location":"#Acknowledgements-1","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The work was inspired by Scala fastparse package and the Julia parsing packages","category":"page"},{"location":"#[Parsers.jl](https://github.com/JuliaData/Parsers.jl)-1","page":"Home","title":"Parsers.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A collection of parsers for date and primitive types.","category":"page"},{"location":"#[TextParse.jl](https://github.com/queryverse/TextParse.jl)-1","page":"Home","title":"TextParse.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A bunch of fast text parsing tools.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"used in CSV.jl\nNullables.jl","category":"page"},{"location":"#","page":"Home","title":"Home","text":"TextParse.jl integrates with CombinedParsers.jl both ways  by type CombinedParsers.AbstractParser <: TextParse.AbstractToken and providing a method for TextParse.tryparsenext.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"CombinedParsers.tryparsenext","category":"page"},{"location":"#Dates.tryparsenext","page":"Home","title":"Dates.tryparsenext","text":"TextParse.tryparsenext(x::AbstractParser,str,i,till,opts=TextParse.default_opts)\n\nTextParse.jl integrates with CombinedParsers.jl both ways.\n\n\njulia> p = (\"Number:\" * Repeat(' ') * TextParse.Numeric(Int))[3]\n🗄 Sequence |> map(#37)\n├─ Number\\:\n├─ \\ *  |> Repeat\n└─ <Int64>\n::Int64\n\njulia> parse(p, \"Number:    42\")\n42\n\njulia> TextParse.tryparsenext(p, \"Number:    42\")\n(Nullable{Int64}(42), 14)\n\n\n\n\n\n","category":"function"},{"location":"#[Automa.jl](https://github.com/BioJulia/Automa.jl)-1","page":"Home","title":"Automa.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A Julia package for text validation, parsing, and tokenizing based on state machine compiler. The package compiles a parser deterministic finite automaton. Processing of parsed tokens is done with actions. No UTF8 support.","category":"page"},{"location":"#[ParserCombinator.jl](https://github.com/andrewcooke/ParserCombinator.jl)-1","page":"Home","title":"ParserCombinator.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"old source base (pre 2016, fixed for Julia 1.0 in 2018)\nusing Nullables\nno iterator API\nperformance \nmutable matcher types\nmatcher types not parametric","category":"page"},{"location":"#main-index-1","page":"Home","title":"Index","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"lib/public.md\"]","category":"page"},{"location":"man/guide/#Getting-Started-1","page":"Overview","title":"Getting Started","text":"","category":"section"},{"location":"man/guide/#Installation-1","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"Install with","category":"page"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"] add https://github.com/gkappler/CombinedParsers.jl","category":"page"},{"location":"man/guide/#Regular-expression-syntax-1","page":"Overview","title":"Regular expression syntax","text":"","category":"section"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"CombinedParsers.jl provides the @re_str macro as a plug-in replacement for the base Julia @r_str macro.","category":"page"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"Base Julia PCRE regular expressions:","category":"page"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"pattern = r\"reg(ular )?ex(?<a>p(ression)?)?\\??\"i\nmr = match(pattern,\"regexp\")","category":"page"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"CombinedParsers.Regexp regular expression:","category":"page"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"using CombinedParsers\nusing CombinedParsers.Regexp","category":"page"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"pattern = re\"reg(ular )?ex(?<a>p(ression)?)?\\??\"i\nmre = match(pattern,\"regexp\")\n\n# The ParseMatch type has `getproperty` and `getindex` methods for handling like `RegexMatch`.\nmre.match\nmre.captures\nmre[2]\nmre[:a]","category":"page"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"note: Note\nThe @re_str supports the following PCRE features☑ fundamentals: sequences, alternations, repetitions optional, matches (*,+,{n}, {min,}, {min,max}, ?)\n☑ escaped characters and generic character types\n☑ character ranges ([])\n☑ non-capturing groups,\n☑ capturing groups, backreferences, subroutines (all by index, relative index and name)\n☑ atomic groups\n☑ lazy repetitions\n☑ conditional expressions\n☑ internal and pattern options setting\n☑ simple assertions (\\A, \\z, \\Z, \\b, \\B, ^, $), \n☑ lookaheads and lookbehinds\n☑ commentsPCRE functionality that is currently not supported:☐ capture groups in lookbehinds.\n☐ ACCEPT, SKIP, COMMIT, THEN, PRUNE, \\K","category":"page"},{"location":"man/guide/#Parsing-1","page":"Overview","title":"Parsing","text":"","category":"section"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"match searches for the first match of the Regex in the String and return a RegexMatch/Parsematch object containing the match and captures, or nothing if the match failed. Base.parse methods parse a String into a Julia type. A CombinedParser p will parse into an instance of result_type(p). For parsers defined with the @re_str the result_types are nested Tuples and Vectors of SubString, Chars and Missing.","category":"page"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"p = re\"(a)*bc?\"\nparse(p,\"aaab\")","category":"page"},{"location":"man/guide/#Iterating-1","page":"Overview","title":"Iterating","text":"","category":"section"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"If a parsing is not uniquely defined different parsings can be lazily iterated, conforming to Julia's iterate interface.","category":"page"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"collect(parse_all(re\"^(a|ab|b)+$\",\"abab\"))\nfor p in parse_all(re\"^(a|ab|b)+$\",\"abab\")\n\tprintln(p)\nend","category":"page"},{"location":"man/guide/#Transformations-1","page":"Overview","title":"Transformations","text":"","category":"section"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"Transform the result of a parsing with map. The result_type inferred automatically using julia type inference.","category":"page"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"p = map(length,re\"(ab)*\")\nresult_type(p)\nparse(p,\"abababab\")","category":"page"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"<!– A supertype T >: result_type(map(f,p)) can be set as result_type with map(f, T, p). –>","category":"page"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"Conveniently, calling getindex(::AbstractParser,::Integer) and map(::Integer,::AbstractParser) create a transforming parser selecting from the result of the parsing.","category":"page"},{"location":"man/guide/#","page":"Overview","title":"Overview","text":"parse(map(2,re\"abc\"),\"abc\")\nparse(re\"abc\"[2],\"abc\")","category":"page"},{"location":"man/pcre/#Parsing-Regular-Expressions-and-constructing-an-equivalent-[AbstractParser](@ref)-1","page":"Regular Expressions","title":"Parsing Regular Expressions and constructing an equivalent AbstractParser","text":"","category":"section"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"This guide demonstrates constructing a recursive parser with the  push! to Either technique by means of a similified parser for regular expressions. ","category":"page"},{"location":"man/pcre/#Characters-and-Escaped-Characters-1","page":"Regular Expressions","title":"Characters and Escaped Characters","text":"","category":"section"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"The simplest regular expression pattern is a character matcher.","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"using CombinedParsers\nusing CombinedParsers.Regexp\nimport CombinedParsers.Regexp: meta_chars\n\nchar_matcher =  Either(\n    \n    with_name(\"character\", \n        CharNotIn([ c for c in meta_chars])),\n    \n    with_name(\"escaped meta\", \n        Sequence(2, # emit unescaped\n            '\\\\', CharIn(meta_chars)))\n    \n)","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"The char_matcher unescapes regex meta_chars:","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"parse(char_matcher,\"a\"; log=true)\nparse(char_matcher,\"\\\\[\"; log=true)","category":"page"},{"location":"man/pcre/#Transforming-a-Parsing-1","page":"Regular Expressions","title":"Transforming a Parsing","text":"","category":"section"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"The parser for escaped and not escaped regular expression characters char_matcher emits Chars","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"result_type(char_matcher)","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"The Julia map method for AbstractParser creates a Transformation parser. The char_matcher is transformed to emit an CharIn matching the unescaped character:","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"char_matcher_parser = map(CharIn,char_matcher);\nresult_type(char_matcher_parser)","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"A parser for a single character is constructed that can then be used to parse that specific Char","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"p = parse(char_matcher_parser,\"\\\\[\")\nparse(p,\"[\")","category":"page"},{"location":"man/pcre/#Repeated-patterns-1","page":"Regular Expressions","title":"Repeated patterns","text":"","category":"section"},{"location":"man/pcre/#Number-of-Repetitions-1","page":"Regular Expressions","title":"Number of Repetitions","text":"","category":"section"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"A basic feature of regular expression is whether a repeatable pattern (e.g. a char) is optional ?, or should be repeated at least once +, any times *, or {min,max} times.","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"The Pair syntax abbreviates mapping a match to a constant value. The do syntax is supported for all CombinedParsers constructors to implicitly call map.","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"import CombinedParsers.Regexp: integer\n\n# https://www.pcre.org/original/doc/html/pcrepattern.html#SEC17\n@with_names repetition = Either(\n    \"?\" => (0,1), # == map(v->(0,1), parser(\"?\"))\n    \"+\" => (1,typemax(Int)),\n    \"*\" => (0,typemax(Int)),\n    Sequence(\n        \"{\", \n        integer,\n        Optional( Sequence(2,\",\",\n            Optional(integer, default=typemax(Int)))),\n        \"}\") do v\n            if v[3] isa Missing\n                (v[2],v[2])\n            else\n                (v[2],v[3])\n            end::Tuple{Int,Int}\n    end\n)","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"repetition parses PCRE repetition syntax into a (min, max):","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"parse(repetition, \"?\")\nparse(repetition, \"*\")\nparse(repetition, \"+\")\nparse(repetition, \"{2}\")\nparse(repetition, \"{5,}\")","category":"page"},{"location":"man/pcre/#[Either](@ref)-1","page":"Regular Expressions","title":"Either","text":"","category":"section"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"Regular expressions can repeat character matchers and other sub-patterns when appending the repetition suffix.","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"repeatable = Either{AbstractParser}(char_matcher_parser)\nnothing # hide","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"We will add capture groups and othe sub-patterns to repeatable later.","category":"page"},{"location":"man/pcre/#Repeatable-patterns,-[Optional](@ref),-[Lazy](@ref)-and-[Atomic](@ref)-1","page":"Regular Expressions","title":"Repeatable patterns, Optional, Lazy and Atomic","text":"","category":"section"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"The CombinedParser to parse a repeated pattern from PCRE syntax","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"@with_names quantified=Sequence(\n        repeatable,\n        Optional(repetition, default=(1,1)),\n        Optional(map(v->convert(Char,v),with_name(\"possessive_quantifier\",CharIn('+','?'))))\n    ) do v\n        pat = v[1]\n        result = if v[2]==(1,1)\n            pat\n        elseif v[2]==(0,1)\n            Optional(pat)\n        else\n            Repeat(pat,v[2])\n        end\n        if v[3] === missing\n            result\n        elseif v[3]=='+'\n            Atomic(result)\n        elseif v[3]=='?'\n            Lazy(result)\n        else\n            result\n        end\n    end\nnothing # hide","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"quantified parses PCRE repetition syntax:","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"p = parse(quantified, raw\"\\++?\", log=true)\nparse(p, \"+++\")","category":"page"},{"location":"man/pcre/#[Sequence](@ref)s-and-Alternations-1","page":"Regular Expressions","title":"Sequences and Alternations","text":"","category":"section"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"Regular expression patterns can be written in sequence, delimited by | for matching either one of several alternatives.","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"@with_names begin\n    sequence = map( v->sSequence(v...),\n        Repeat( quantified ))\n\n    alternation = Sequence(\n        sequence, \n        Repeat(Sequence(2, '|',sequence))) do v\n            sEither(v[1],v[2]...)::AbstractParser\n        end\nend\nnothing # hide","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"The alternation parser transforms a regex string into a parser","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"result_type(alternation)\np = parse(alternation, \"ab|c\", log=(:sequence, :alternation))\nparse(p, \"c\")","category":"page"},{"location":"man/pcre/#[Capture](@ref)s-1","page":"Regular Expressions","title":"Captures","text":"","category":"section"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"Parentheses allow groupings that are repeatable.","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"import CombinedParsers.Regexp: name\n\n@with_names begin\n    noncapture_group=Sequence( 2, \"(?:\",alternation,\")\")\n\n    capture_group=Sequence(\"(\",alternation,\")\") do v\n                Capture(v[2])\n    end;\nend\nnothing # hide","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"The push! to Either technique allows for the construction of recursive parsers.","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"push!(repeatable,capture_group);\npush!(repeatable,noncapture_group);\nnothing # hide","category":"page"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"p = parse(alternation, \"(ab|c)+\", log=(:capture_group, repeatable))\nparse(p, \"cabcabab\")","category":"page"},{"location":"man/pcre/#[LookAround](@ref)-1","page":"Regular Expressions","title":"LookAround","text":"","category":"section"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"@with_names lookahead=Sequence(\n    2,\n    \"(\",\n    Either(Sequence(\n            v -> look_ahead(true,v[2]),\n            Either(\"?=\",\"*positive_lookahead:\",\"*pla:\"),\n            alternation),\n        Sequence(\n            v -> look_ahead(false,v[2]),\n            Either(\"?!\",\"*negative_lookahead:\",\"*nla:\"),\n            alternation)),\n    \")\");\n@with_names lookbehind=Sequence(\n    2,\n    \"(\",\n    Either(Sequence(v -> look_behind(true,v[2]),\n            Either(\"?<=\",\"*positive_lookbehind:\",\"*plb:\"),alternation),\n        Sequence(v -> look_behind(false,v[2]),\n            Either(\"?<!\",\"*negative_lookbehind:\",\"*nlb:\"),alternation)),\n    \")\");\n\npush_first!(repeatable,lookahead);\npush_first!(repeatable,lookbehind);\n\nnothing # hide","category":"page"},{"location":"man/pcre/#Regular-Expression-Brackets-1","page":"Regular Expressions","title":"Regular Expression Brackets","text":"","category":"section"},{"location":"man/pcre/#","page":"Regular Expressions","title":"Regular Expressions","text":"import CombinedParsers.Regexp: bracket\npush!(repeatable,bracket);\nbracket","category":"page"}]
}
