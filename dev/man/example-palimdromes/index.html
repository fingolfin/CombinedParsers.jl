<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Palimdrome&lt;:CombinedParsers Â· CombinedParsers.jl</title><link rel="canonical" href="https://gkappler.github.io/CombinedParsers.jl/man/example-palimdromes/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CombinedParsers.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../guide/">Overview</a></li><li><a class="tocitem" href="../user/">User Guide</a></li><li><a class="tocitem" href="../pcre-compliance/">PCRE Compliance</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example-person/">Name and addresses</a></li><li><a class="tocitem" href="../example-number-ranges/">Number sequences</a></li><li class="is-active"><a class="tocitem" href>Palimdrome&lt;:CombinedParsers</a><ul class="internal"><li><a class="tocitem" href="#.-A-non-word-skipping-palimdrome-regex-1"><span>1. A non-word skipping palimdrome regex</span></a></li><li><a class="tocitem" href="#.-A-non-word-skipping-Palimdrome:CombinedParser-1"><span>2. A non-word skipping <code>Palimdrome&lt;:CombinedParser</code></span></a></li></ul></li><li><a class="tocitem" href="../pcre/">Regular Expressions</a></li><li><a class="tocitem" href="../json/">JSON</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/public/">Public</a></li><li><a class="tocitem" href="../../lib/internals/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Palimdrome&lt;:CombinedParsers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Palimdrome&lt;:CombinedParsers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gkappler/CombinedParsers.jl/docs/docs/src/man/example-palimdromes.jl" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Palimdromes:CombinedParser:-a-Tutorial-for-writing-your-combinable-Parser-1"><a class="docs-heading-anchor" href="#Palimdromes:CombinedParser:-a-Tutorial-for-writing-your-combinable-Parser-1"><code>Palimdromes&lt;:CombinedParser</code>: a Tutorial for writing your combinable Parser</a><a class="docs-heading-anchor-permalink" href="#Palimdromes:CombinedParser:-a-Tutorial-for-writing-your-combinable-Parser-1" title="Permalink"></a></h1><p>Palimdromes are an interesting example for parsing because intuitively programmers as well as laymen understand the problem: the text is identical when read from left to right, as we are used to do, or when read from right to left in reverse, when we read only the letters and discard all non-word characters.</p><p>This example enables you to write your own custom <code>CombinedParser</code> based off a minimal template.</p><h2 id=".-A-non-word-skipping-palimdrome-regex-1"><a class="docs-heading-anchor" href="#.-A-non-word-skipping-palimdrome-regex-1">1. A non-word skipping palimdrome regex</a><a class="docs-heading-anchor-permalink" href="#.-A-non-word-skipping-palimdrome-regex-1" title="Permalink"></a></h2><p>The PCRE test case contains nice examples of non-trivial palimdromes. The tested regular expression matching these palimdromes is cryptic and requires arcane reasoning even to the initiated.</p><pre><code class="language-julia">using CombinedParsers
using CombinedParsers.Regexp
# defines parsers for pcre tests:
CombinedParsers.Regexp.@pcre_tests;

pt = pcre_test&quot;&quot;&quot;
/^\W*+(?:((.)\W*+(?1)\W*+\2|)|((.)\W*+(?3)\W*+\4|\W*+.\W*+))\W*+$/i
    1221
 0: 1221
 1: 1221
 2: 1
    Satan, oscillate my metallic sonatas!
 0: Satan, oscillate my metallic sonatas!
 1: &lt;unset&gt;
 2: &lt;unset&gt;
 3: Satan, oscillate my metallic sonatas
 4: S
    A man, a plan, a canal: Panama!
 0: A man, a plan, a canal: Panama!
 1: &lt;unset&gt;
 2: &lt;unset&gt;
 3: A man, a plan, a canal: Panama
 4: A
    Able was I ere I saw Elba.
 0: Able was I ere I saw Elba.
 1: &lt;unset&gt;
 2: &lt;unset&gt;
 3: Able was I ere I saw Elba
 4: A
\= Expect no match
    The quick brown fox
No match
&quot;&quot;&quot;</code></pre><pre><code class="language-none">Pattern: r(e)&quot;^\W*+(?:((.)\W*+(?1)\W*+\2|)|((.)\W*+(?3)\W*+\4|\W*+.\W*+))\W*+$&quot;i
Test Examples:
   1. 1221
   2. Satan, oscillate my metallic sonatas!
   3. A man, a plan, a canal: Panama!
   4. Able was I ere I saw Elba.
Not Examples:
   1. The quick brown fox
</code></pre><p>It is interesting that this case ignoring PCRE pattern matches palimdromes:</p><pre><code class="language-julia">re = Regex(pt.pattern...)</code></pre><pre><code class="language-none">r&quot;^\W*+(?:((.)\W*+(?1)\W*+\2|)|((.)\W*+(?3)\W*+\4|\W*+.\W*+))\W*+$&quot;i</code></pre><p>I figure the expression is hard to construct and come up with. The easy part is that the pattern needs to ignore case and whitespace <code>\W</code>.</p><pre><code class="language-julia"># TODO: re&quot;\W&quot; show `UnicodeClass`</code></pre><p>The pattern makes intense use of backreferences and subroutines. I find it hard to understand the compact captures <code>(.)</code>, why no backreference <code>\1</code>, why no subroutine <code>(?2)</code>?, even in a nested tree display:</p><pre><code class="language-julia">cp = Regcomb(pt.pattern...)</code></pre><pre><code class="language-none">ðŸ—„ Sequence |&gt; regular expression combinator with 4 capturing groups
â”œâ”€ ^ AtStart
â”œâ”€ (?&gt;[^^_\p{1:5}\p{9:11}]*) CharNotIn |&gt; Repeat |&gt; Atomic
â”œâ”€ |ðŸ—„... Either
â”‚  â”œâ”€ (|ðŸ—„...) Either |&gt; Capture 1
â”‚  â”‚  â”œâ”€ ðŸ—„ Sequence
â”‚  â”‚  â”‚  â”œâ”€ ([^^\n]) CharNotIn |&gt; Capture 2
â”‚  â”‚  â”‚  â”œâ”€ (?&gt;[^^_\p{1:5}\p{9:11}]*) CharNotIn |&gt; Repeat |&gt; Atomic
â”‚  â”‚  â”‚  â”œâ”€ (?1) Subroutine
â”‚  â”‚  â”‚  â”œâ”€ (?&gt;[^^_\p{1:5}\p{9:11}]*) CharNotIn |&gt; Repeat |&gt; Atomic
â”‚  â”‚  â”‚  â””â”€ (?i\g{2}) Backreference |&gt; set_options
â”‚  â”‚  â””â”€  Always
â”‚  â””â”€ (|ðŸ—„...) Either |&gt; Capture 3
â”‚     â”œâ”€ ðŸ—„ Sequence
â”‚     â”‚  â”œâ”€ ([^^\n]) CharNotIn |&gt; Capture 4
â”‚     â”‚  â”œâ”€ (?&gt;[^^_\p{1:5}\p{9:11}]*) CharNotIn |&gt; Repeat |&gt; Atomic
â”‚     â”‚  â”œâ”€ (?3) Subroutine
â”‚     â”‚  â”œâ”€ (?&gt;[^^_\p{1:5}\p{9:11}]*) CharNotIn |&gt; Repeat |&gt; Atomic
â”‚     â”‚  â””â”€ (?i\g{4}) Backreference |&gt; set_options
â”‚     â””â”€ ðŸ—„ Sequence
â”‚        â”œâ”€ (?&gt;[^^_\p{1:5}\p{9:11}]*) CharNotIn |&gt; Repeat |&gt; Atomic
â”‚        â”œâ”€ [^^\n] CharNotIn
â”‚        â””â”€ (?&gt;[^^_\p{1:5}\p{9:11}]*) CharNotIn |&gt; Repeat |&gt; Atomic
â”œâ”€ (?&gt;[^^_\p{1:5}\p{9:11}]*) CharNotIn |&gt; Repeat |&gt; Atomic
â””â”€ |ðŸ—„... Either
   â”œâ”€ $ AtEnd
   â””â”€ (?=ðŸ—„) PositiveLookahead
      â””â”€ ðŸ—„ Sequence |&gt; map(#51)
         â”œâ”€ \n 
         â””â”€ $ AtEnd
::Tuple{AtStart,Array{Char,1},Union{Always, Tuple{Any,Any,Any,Vararg{Any,N} where N}},Array{Char,1},AtEnd}
</code></pre><p>Theoretical linguists, I wonder, is the minimum number of capture groups 4, for a regular expression matching palimdromes?</p><p>Matching example 3 is fast</p><pre><code class="language-julia">using BenchmarkTools
@btime match(re, pt.test[3].sequence)</code></pre><pre><code class="language-none">RegexMatch(&quot;A man, a plan, a canal: Panama!&quot;, 1=nothing, 2=nothing, 3=&quot;A man, a plan, a canal: Panama&quot;, 4=&quot;A&quot;)</code></pre><p>Writing a palimdrome parser should be easier. And with julia compiler it should be faster.</p><p>In practice <code>CombinedParsers</code> <a href="man/@ref"><code>Regcomb</code></a> of the regular expression will detect palimdromes too. Palimdrome matching provides an interesting cross-parser performance benchmark.</p><pre><code class="language-julia">@btime match(cp, pt.test[3].sequence)</code></pre><pre><code class="language-none">ParseMatch(&quot;A man, a plan, a canal: Panama!&quot;, 1=&quot;&quot;, 2=nothing, 3=&quot;A man, a plan, a canal: Panama&quot;, 4=&quot;A&quot;)</code></pre><p><code>CombinedParsers.Regexp.Subroutine</code> matching is slow because the current implementation is using state-copies of captures. (TODO: could be a stack?).</p><h2 id=".-A-non-word-skipping-Palimdrome:CombinedParser-1"><a class="docs-heading-anchor" href="#.-A-non-word-skipping-Palimdrome:CombinedParser-1">2. A non-word skipping <code>Palimdrome&lt;:CombinedParser</code></a><a class="docs-heading-anchor-permalink" href="#.-A-non-word-skipping-Palimdrome:CombinedParser-1" title="Permalink"></a></h2><p>This example of <code>Palimdrome&lt;:CombinedParser</code> is a much faster palimdrome parser and more interesting and more easy to write. It mimics the human readable palimdrome rule that is clear and quite easy to comprehend:</p><p>the text is identical when read from left to right, as we are used to do, or when read from right to left in reverse, when we read only the letters and skip all non-word characters.</p><p>This rule is efficient programming in natural language. After defining the parser, the third part of the example discusses the design of match iteration in <code>CombinedParsers</code>.</p><h4 id="Prerequisite:-Skipping-whitespace-1"><a class="docs-heading-anchor" href="#Prerequisite:-Skipping-whitespace-1">Prerequisite: Skipping whitespace</a><a class="docs-heading-anchor-permalink" href="#Prerequisite:-Skipping-whitespace-1" title="Permalink"></a></h4><p>For the string <code>&quot;two   words&quot;</code>,  from the point of index 4 (<code>&#39; &#39;</code> after &quot;from&quot;) the next word character after skipping whitespace left and right are indices of 3 (tw<code>o</code>) and 7 (<code>w</code>ords). In Julia syntax, this is expressed in terms of <code>direction</code> (functions <code>Base.prevind</code> and <code>Base.nextind</code> return next index to left or right), and <code>word_char::T</code>, what makes up a word character (provided method <code>CombinedParser.ismatch(char,parser::T)::Bool</code>.)</p><pre><code class="language-julia">@inline function seek_word_char(direction,str,i,
                                till=lastindex(str),
                                word_char=UnicodeClass(:L))
    i=direction(str,i)
    while i&gt;0 &amp;&amp; i&lt;=till &amp;&amp; !CombinedParsers.ismatch((@inbounds str[i]),word_char)
        i=direction(str,i)
    end
    return i
end
( prev_index=seek_word_char(prevind, &quot;two   words&quot;, 4),
  next_index=seek_word_char(nextind, &quot;two   words&quot;, 4) )</code></pre><pre><code class="language-none">(prev_index = 3, next_index = 7)</code></pre><h4 id="Subtyping-:-CombinedParser-1"><a class="docs-heading-anchor" href="#Subtyping-:-CombinedParser-1">Subtyping <code>&lt;: CombinedParser</code></a><a class="docs-heading-anchor-permalink" href="#Subtyping-:-CombinedParser-1" title="Permalink"></a></h4><pre><code class="language-julia">struct Palimdrome{P} &lt;: CombinedParser{SubString}
    word_char::P
    Palimdrome(x) = new{typeof(x)}(x)
    # UnicodeClass(:L) creation currently is slow, but required only once by default.
    Palimdrome() = Palimdrome(UnicodeClass(:L))
end
# @btime UnicodeClass(:L)</code></pre><h4 id="Matching-1"><a class="docs-heading-anchor" href="#Matching-1">Matching</a><a class="docs-heading-anchor-permalink" href="#Matching-1" title="Permalink"></a></h4><p>A custom parser needs a method to determine if there is a match at a position, and its state. How can this be implemented for a palimdrome? There are two strategies:</p><ol><li>inside-out:  expand left and right from position until word character left does not match word character at right. Succeed if a minimal length is met. Fail otherwise.</li><li>outside-in: start left and right, move positions towards middle until they are at word characters and succeed if left and right positions meet, compare these characters, and proceed to the next positions if the word characters match or fail if there is a mismatch. (This might be <a href="https://stackoverflow.com/questions/21403782/the-fastest-method-of-determining-if-a-string-is-a-palindrome">the-fastest-method-of-determining-if-a-string-is-a-palindrome</a>.  But I figure finding all palimdrome matches in a string is slow because you would be required to test for all possible substrings.)</li></ol><p>The inside out strategy seems easier and faster.</p><h4 id="Matching-greedy-1"><a class="docs-heading-anchor" href="#Matching-greedy-1">Matching greedy</a><a class="docs-heading-anchor-permalink" href="#Matching-greedy-1" title="Permalink"></a></h4><p>With the inside-out stratedy, the implementation greedily expands over non-word characters. The state of a match will be represented as</p><pre><code class="language-julia">CombinedParsers.state_type(::Type{&lt;:Palimdrome}) =
    NamedTuple{(:left,:center,:right),Tuple{Int,Int,Int}}</code></pre><p>For the inside-out strategy the <code>Palimdrome&lt;:CombinedParser</code> is a parser that looks behind the current index. The start index of a palimdrome match is its center.</p><pre><code class="language-julia">Base.prevind(str,after::Int,p::Palimdrome,state) =
    state.center
Base.nextind(str,i::Int,p::Palimdrome,state) =
    nextind(str,state.right)</code></pre><p><code>prevind</code> and <code>nextind</code> methods for a custom parser are required during the match iteration process.</p><p>Testing initially for a match at <code>posi</code> is <code>_iterate(parser,str,till,posi,after,state::Nothing)</code>. (Feedback appreciated: Would is be more efficient change the <code>_iterate</code> internal API for the first match to arity 4?) The internal API calls (for the center index 18): TODO: state = _iterate(Palimdrome(),s,18) _iterate matches the right part of the palimdrome iif posi at the center of a palimdrome.</p><ul><li>greedily expand status and parsing position over non-word characters.</li></ul><pre><code class="language-">function CombinedParsers._iterate(x::Palimdrome,
                                  str, till,
                                  posi, after,
                                  state::Nothing)
    right_ = left_ = left = right = posi
    while left&gt;0 &amp;&amp; right&lt;=till &amp;&amp; lowercase(@inbounds str[left])==lowercase(@inbounds str[right])
        # if we cannot expand, we can succeed with current (left_,right_)
        right_ = right
        left_ = left # state to left range, the leftmost index of last match
        left =  seek_word_char(
            prevind,str,
            left,till,x.word_char)
        right = seek_word_char(
            nextind,str,
            right,till,x.word_char)
    end
    left, left_, right_, right
    if left_ == right_</code></pre><p>skip trivial short palimdromes</p><pre><code class="language-julia">        nothing
    else
        tuple(nextind(str,right_),
              (left=left_, center=posi, right=right_))
    end
end
s=pt.test[3].sequence
state = _iterate(Palimdrome(),s,lastindex(s),18,18,nothing)</code></pre><p><a href="../../lib/internals/#CombinedParsers._iterate"><code>_iterate</code></a> is called when the public API <code>match</code> or <code>parse</code> is used. Match searches for a center index and then matched the right part of the palimdrome.</p><pre><code class="language-">p = Palimdrome()
m = match(p,s)</code></pre><p>The result of a parsing is the matching substring from left to right.</p><pre><code class="language-julia"># Base.get(x::Palimdrome, str, state) = SubString(str,state...)
# TODO: dispatch Base.get(x::CombinedParser, str, till::Int, after::Int, posi::Int, state) = Base.get(x, str, after, posi, state)
# TODO: dispatch Base.get(x::CombinedParser, str, after::Int, posi::Int, state) = Base.get(x, str, posi, state)
# TODO: dispatch Base.get(x::CombinedParser, str, posi::Int, state) = Base.get(x, str, state)
# Implementing `Base.get` with the full argument range:
Base.get(x::Palimdrome, str, till, after, posi, state) =
    SubString(str,state.left,state.right)</code></pre><p>The match result is matching the first palimdrome, which is short and simple - but not what we want.</p><pre><code class="language-">get(m)</code></pre><h4 id="Iterating-through-matches-1"><a class="docs-heading-anchor" href="#Iterating-through-matches-1">Iterating through matches</a><a class="docs-heading-anchor-permalink" href="#Iterating-through-matches-1" title="Permalink"></a></h4><p>The longest palimdrome is matched too:</p><pre><code class="language-">p = Palimdrome()
[ get(m) for m in match_all(p,s) ]</code></pre><p>The set of all palimdromes in a text includes the shorter palimdromes contained in longer ones. Provide a method to iterate the previous state:</p><pre><code class="language-">&quot;Shrinking `state` match&quot;
function CombinedParsers._iterate(x::Palimdrome, str, till, posi, after, state)
    left_, posi_, right_ = state
    left =  seek_word_char(
        nextind,str,
        left_,till,x.word_char)
    right = seek_word_char(
        prevind,str,
        right_,till,x.word_char)
    if left &gt;= right # left == posi
        nothing
    else
        tuple(nextind(str,right),
              (left=left, center=posi_, right=right))
    end
end

[ get(m) for m in match_all(p,s) ]</code></pre><p>Note that the previous greedy-only behaviour is atomic on terms of regular expression, which can be restored with <a href="../../lib/public/#CombinedParsers.Atomic"><code>Atomic</code></a></p><pre><code class="language-">p = Atomic(Palimdrome())
get.(match_all(p,s)) |&gt; collect</code></pre><p><code>Base.filter</code> can filter out short palimdromes:</p><pre><code class="language-">long_palimdrome = FilterParser(Palimdrome()) do sequence, till, posi, after, state
    left,posi,right=state
    right-left+1 &gt; 5
end
get(match(long_palimdrome,s))</code></pre><p>Note that the PCRE pattern included outside non-words, specifically the tailing <code>!</code>.</p><pre><code class="language-">re = Regex(pt.pattern...)
match(re,s)
#``CombinedParsers` are designed with iteration in mind, and a small match set reduces computational time when iterating through all matches.</code></pre><p><code>Palimdrome</code> matches palimdromes with word-char boundaries. The PCRE pattern includes non-words matches in the padding of palimdromes, a superset of <code>Palimdrome</code>. PCRE-equivalent matching can be achieved by combining the stricly matching <code>Palimdrome</code> with parsers for the padding.</p><pre><code class="language-">padding=Repeat(CharNotIn(p.parser.word_char))
CombinedParsers.state_type(Palimdrome()*padding|&gt;typeof)
get.(match_all(p*padding,s)) |&gt; collect</code></pre><p><code>Palimdrome</code> matches from center to right, like a lookbehind parser.</p><pre><code class="language-">match_all(p*padding,s) |&gt; collect

palimdrome = FilterParser(
    Sequence(
        2,
        Lazy(Repeat(AnyChar())),
        Atomic(Palimdrome()))) do sequence, till, posi, after, state</code></pre><pre><code class="language-none">       @show posi,state</code></pre><pre><code class="language-">    posi==state[2][1]
end

p = AtStart() * padding * (palimdrome) * padding * AtEnd()</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../example-number-ranges/">Â« Number sequences</a><a class="docs-footer-nextpage" href="../pcre/">Regular Expressions Â»</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 20 June 2020 13:56">Saturday 20 June 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
