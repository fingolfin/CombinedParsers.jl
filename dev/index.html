<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CombinedParsers.jl</title><link rel="canonical" href="https://gkappler.github.io/CombinedParsers.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CombinedParsers.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Package-Features"><span>Package Features</span></a></li><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Example:-read-and-evaluate-arithmetical-terms-for-rational-numbers"><span>Example: read and evaluate arithmetical terms for rational numbers</span></a></li><li class="toplevel"><a class="tocitem" href="#Useful-Design"><span>Useful Design</span></a></li><li><a class="tocitem" href="#Optimization-Strategy"><span>Optimization Strategy</span></a></li><li class="toplevel"><a class="tocitem" href="#Acknowledgements"><span>Acknowledgements</span></a></li><li><a class="tocitem" href="#[TextParse.jl](https://github.com/queryverse/TextParse.jl)"><span>TextParse.jl</span></a></li><li><a class="tocitem" href="#Inspirations"><span>Inspirations</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li class="toplevel"><a class="tocitem" href="#Library-Outline"><span>Library Outline</span></a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="man/guide/">Overview</a></li><li><a class="tocitem" href="man/user/">User Guide</a></li><li><a class="tocitem" href="man/example-either-trie/">Prefix-Tree Matching</a></li><li><a class="tocitem" href="man/pcre-compliance/">PCRE Compliance</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="man/example-person/">What is Parsing? Names...</a></li><li><a class="tocitem" href="man/example-number-ranges/">Representations: Number sequences</a></li><li><a class="tocitem" href="man/pcre/">Regular Expressions</a></li><li><a class="tocitem" href="man/example-palindromes/">struct Palindrome&lt;:CombinedParser</a></li><li><a class="tocitem" href="man/json/">JSON</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="lib/public/">Public</a></li><li><a class="tocitem" href="lib/regexp/">Regexp</a></li><li><a class="tocitem" href="lib/internals/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gkappler/CombinedParsers.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CombinedParsers.jl-Documentation"><a class="docs-heading-anchor" href="#CombinedParsers.jl-Documentation">CombinedParsers.jl Documentation</a><a id="CombinedParsers.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#CombinedParsers.jl-Documentation" title="Permalink"></a></h1><p>A package for combining parsers and transforming strings into julia types.</p><p>Compose parsers with the functional <a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinator paradigm</a>, utilize Julia&#39;s type inference for transformations, log conveniently for debugging, and let Julia compile your parser for performance.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>CombinedParsers.jl</code> is currently an α release.	The first official released is prepared for JuliaCon2020.</p></div></div><h2 id="Package-Features"><a class="docs-heading-anchor" href="#Package-Features">Package Features</a><a id="Package-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Package-Features" title="Permalink"></a></h2><ul><li>Speed<ul><li><a href="man/pcre-compliance/">write parsers faster than <code>Base.PCRE</code></a>, optimized by the Julia compiler for parametric parser and state types.</li><li>Fast <code>@generated function</code>s for sequences.</li><li>Fast Trie-based scanning (<a href="man/example-either-trie/">example</a>)</li><li>Compile with your custom parsing algorithm (<a href="man/example-palindromes/">example</a>)</li><li>(planned: memoization)</li><li>(planned: lazy transformations)</li></ul></li><li>Simplicity<ul><li>Clear <a href="lib/public/#CombinedParsers.@syntax"><code>@syntax</code></a> integrates <a href="lib/public/#Base.map"><code>map</code></a> transformations with Julia <a href="lib/public/#CombinedParsers.result_type"><code>result_type</code></a> inference.</li><li><a href="https://github.com/JuliaCollections/AbstractTrees.jl">AbstractTrees.jl</a> interface provides colored and clearly layed out printing in the REPL.</li><li>Convenient logging of the parsing process <a href="lib/public/#CombinedParsers.with_name"><code>with_name</code></a>s and <a href="@ref"><code>SideeffectParser</code></a>s.</li></ul></li><li>Interoperability<ul><li><a href="https://github.com/queryverse/TextParse.jl">TextParse.jl</a>: existing <code>TextParse.AbstractToken</code> implementations can be used with CombinedParsers. <code>CombinedParser</code> provide <code>TextParse.tryparsenext</code> and can be used e.g. in CSV.jl.</li><li>Pure Julia regular expression parsers are provided with the <a href="lib/public/#CombinedParsers.Regexp.@re_str"><code>@re_str</code></a> macro, a plug-in replacement for <code>Base.@r_str</code>.</li><li>Tested on the <a href="man/pcre-compliance/">PCRE pattern test set</a>.</li></ul></li><li>Generality<ul><li>UTF8</li><li>All valid parsings can be <a href="@ref"><code>Base.iterate</code></a>d lazily.</li><li>Higher-order parsers depending on the parsing state allow for not context-free parsers (<a href="@ref"><code>after</code></a>).</li><li>CombinedParsers generalize from strings to parsing any sequence type supporting <code>getindex</code>, <code>nextind</code>, <code>prevind</code> methods.</li></ul></li></ul><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>The <a href="man/guide/#Overview">Overview</a> provides a tutorial explaining how to get started using CombinedParsers. The <a href="man/user/">User guide</a> provides a summary of CombinedParsers types. Some examples of packages using CombinedParsers can be found on the <a href="#Examples">Examples</a> page. See the <a href="#main-index">Index</a> for the complete list of documented functions and types.</p><p>Install with</p><pre><code class="language-julia">] add https://github.com/gkappler/CombinedParsers.jl</code></pre><h2 id="Example:-read-and-evaluate-arithmetical-terms-for-rational-numbers"><a class="docs-heading-anchor" href="#Example:-read-and-evaluate-arithmetical-terms-for-rational-numbers">Example: read and evaluate arithmetical terms for rational numbers</a><a id="Example:-read-and-evaluate-arithmetical-terms-for-rational-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-read-and-evaluate-arithmetical-terms-for-rational-numbers" title="Permalink"></a></h2><p>Parsing is reading and transforming a sequence of characters. This example reads and evaluates arithmetical terms for rational numbers. Subterms can use algebraic operators <code>+-*/</code> that will be evaluated with </p><pre><code class="language-julia-repl">julia&gt; function evaluate( (start, operation_values) )
           aggregated_value::Rational{Int} = start
           for (op,val) in operation_values
               aggregated_value = eval( Expr(:call, Symbol(op),
       			              aggregated_value, val
       			              ))
           end
           return aggregated_value
       end
evaluate (generic function with 1 method)

julia&gt; evaluate( (0, [ (&#39;+&#39;,1), (&#39;+&#39;,1) ]) )
2//1

julia&gt; evaluate( (1, [ (&#39;*&#39;,2), (&#39;*&#39;,3) ]) )
6//1</code></pre><h3 id="TextParse.Numeric(Int)"><a class="docs-heading-anchor" href="#TextParse.Numeric(Int)"><code>TextParse.Numeric(Int)</code></a><a id="TextParse.Numeric(Int)-1"></a><a class="docs-heading-anchor-permalink" href="#TextParse.Numeric(Int)" title="Permalink"></a></h3><p><code>CombinedParsers</code> provides constructors to combine parsers and transform (sub-)parsings arbitrarily with julia syntax. Combinator constructors are discussed in the <a href="man/user/">user guide</a>. A term expression has sub terms, either fast <code>TextParse.Numeric(Int)</code> integer numbers, converted to <code>Rational{Int}</code>, or something in parentheses, which is attended to below:</p><pre><code class="language-julia">using CombinedParsers
using TextParse
@syntax subterm = Either{Rational{Int}}(
	Any[ map(Rational{Int}, TextParse.Numeric(Int)) ])</code></pre><p>Terms are sequences of subterms interleaved with operators. CombinedParsers.Sequence can be built with operator <code>*</code> like Julia string concatenation.</p><pre><code class="language-julia">rational_products = Sequence(
	evaluate,
	subterm, Repeat(
		Sequence( CharIn(&quot;*/&quot;), subterm ) )
)

@syntax term = map(
    evaluate,
    rational_products*Repeat(
		CharIn(&quot;+-&quot;) * rational_products
	)
);</code></pre><p>A subterm can also be a nested term in parenthesis</p><pre><code class="language-julia">@syntax for parenthesis in subterm
    Sequence(2,&quot;(&quot;,term,&quot;)&quot;)
end</code></pre><p><code>@syntax</code> registers <code>@term_string</code> macro for parsing.</p><pre><code class="language-julia-repl">julia&gt; term&quot;(1+2)/5&quot;
3//5</code></pre><p>The defined <code>CombinedParser</code> <code>term</code> can be used as a function for colorful logging of the parsing process.</p><pre><code class="language-julia-repl">julia&gt; term(&quot;1/((1+2)*4+3*(5*2))&quot;,log = [:parenthesis])
   match parenthesis: 1/((1+2)*4+3*(
                         ^___^
   match parenthesis: *4+3*(5*2))
                           ^___^
   match parenthesis: 1/((1+2)*4+3*(5*2))
                        ^_______________^
1//42</code></pre><p><a href="https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Answer_to_the_Ultimate_Question_of_Life,_the_Universe,_and_Everything_(42)">Is every rational answer ultimately the inverse of a universal question in life?</a></p><p>The parser representation can be printed as a tree</p><pre><code class="language-julia-repl">julia&gt; term
🗄 Sequence |&gt; map(#161) |&gt; with_name(:term)
├─ 🗄 Sequence |&gt; map(#161)
│  ├─ |🗄... Either |&gt; with_name(:subterm)
│  │  ├─ 🗄 Sequence |&gt; map(#169) |&gt; with_name(:parenthesis)
│  │  │  ├─ \(
│  │  │  ├─ 🗄 Sequence |&gt; map(#161) |&gt; with_name(:term)
│  │  │  │  ├─ 🗄 Sequence |&gt; map(#161)
│  │  │  │  └─ 🗄* Sequence |&gt; Repeat
│  │  │  └─ \)
│  │  └─ TextParse.Numeric{Int64} TextParse.Numeric |&gt; map(#163)
│  └─ 🗄* Sequence |&gt; Repeat
│     ├─ [\*/] CharIn
│     └─ |🗄... Either |&gt; with_name(:subterm)
│        ├─ 🗄 Sequence |&gt; map(#169) |&gt; with_name(:parenthesis)
│        │  ├─ \(
│        │  ├─ 🗄 Sequence |&gt; map(#161) |&gt; with_name(:term)
│        │  └─ \)
│        └─ TextParse.Numeric{Int64} TextParse.Numeric |&gt; map(#163)
└─ 🗄* Sequence |&gt; Repeat
   ├─ [\+\-] CharIn
   └─ 🗄 Sequence |&gt; map(#161)
      ├─ |🗄... Either |&gt; with_name(:subterm)
      │  ├─ 🗄 Sequence |&gt; map(#169) |&gt; with_name(:parenthesis)
      │  │  ├─ \(
      │  │  ├─ 🗄 Sequence |&gt; map(#161) |&gt; with_name(:term)
      │  │  └─ \)
      │  └─ TextParse.Numeric{Int64} TextParse.Numeric |&gt; map(#163)
      └─ 🗄* Sequence |&gt; Repeat
         ├─ [\*/] CharIn
         └─ |🗄... Either |&gt; with_name(:subterm)
            ├─ 🗄 Sequence |&gt; map(#169) |&gt; with_name(:parenthesis)
            └─ TextParse.Numeric{Int64} TextParse.Numeric |&gt; map(#163)
::Rational{Int64}</code></pre><h1 id="Useful-Design"><a class="docs-heading-anchor" href="#Useful-Design">Useful Design</a><a id="Useful-Design-1"></a><a class="docs-heading-anchor-permalink" href="#Useful-Design" title="Permalink"></a></h1><ul><li>WikitextParser.jl is a <code>CombinedParser</code> for parsing <a href="https://en.wikipedia.org/wiki/Help:Wikitext">wikitext syntax</a>, quite comprehensibly and representing Wikipedia articles within Julia.</li><li>OrgmodeParser.jl is a <code>CombinedParser</code> for parsing main <a href="https://orgmode.org/">org mode</a> syntax, representing org files within Julia.</li><li>CombinedParserTools.jl is currently more or less my own workspace to provide a set of re-useable parsers.</li><li>Tries.jl is the abstract implementation of the fast prefix-tree matching in <code>CombinedParsers</code> (see <a href="https://gkappler.github.io/CombinedParsers.jl/dev/man/example-either-trie/">docs</a>)</li></ul><p>If you want to work with any of these open source packages, I will gladly provide professional support. If you are writing your own recursive <code>CombinedParser</code> and seek inspiration, you might find these comprehensive examples interesting. (pre-\alpha, so beware, dragons!)</p><p>The <code>CombinedParsers</code> design </p><ul><li>is fast due to Julia parametric types, and compiler optimizations with generated functions,</li><li>its strictly typed parsing defines the domain data types,</li><li>is composable and optimizable with Julia method dispatch,</li><li>provides flexible public API for parsing, matching, iteration</li></ul><p>Making Julia parametric types central for the parser design allows equal automation of the data pipeline after parsing!</p><ul><li>fast db-indexing of text streams (e.g. logging): If you need support indexing logging streams into a (SQL-)Database, the (currently) proprietary TypeGraphs.jl provides <code>CombinedParsers</code> plug and play: Table schemas are infered from your parser.</li><li>fast HTTP-serving of parsed data: If you need support with a parsing server-client infrastructure, the (currently) proprietary GraphQLAlchemy.jl provides <code>CombinedParsers</code> plug and play: GraphQL schemas and resolver are infered from your parser.</li><li>fast out-of core data science/AI on your parsed data: If you need support with storing parsed data in optimized memory-mapped JuliaDB, TypeDB.jl provides <code>CombinedParsers</code> plug and play. </li><li>fast scientific measurements in a data graph: FilingForest IA.jl provides <code>CombinedParsers</code> plug and play: even for recursively nested data.</li></ul><p>All (currently) proprietary packages are default-over-configuration for fast integration, and are in active development.</p><h2 id="Optimization-Strategy"><a class="docs-heading-anchor" href="#Optimization-Strategy">Optimization Strategy</a><a id="Optimization-Strategy-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Strategy" title="Permalink"></a></h2><p>CombinedParsers.jl is tested and benchmarked against the PCRE C library testset.</p><ul><li><a href="man/pcre-compliance/#Compliance-with-the-PCRE-test-set">Compliance with the PCRE test set</a></li><ul><li><a href="man/pcre-compliance/#Test-Overview">Test Overview</a></li><ul><li><a href="man/pcre-compliance/#Performance-Overview:">Performance Overview:</a></li><li><a href="man/pcre-compliance/#Benchmark-ratios-histogram:">Benchmark ratios histogram:</a></li></ul><li><a href="man/pcre-compliance/#Unsupported">Unsupported</a></li></ul></ul><p>This strategy allows for efficient benchmarking of code optimizations on many Regex and other syntax patterns. Explorations for optimization are in git branches:</p><ul></ul><p>Parsing times for Int, operators, brackets are</p><pre><code class="language-julia-repl">julia&gt; using BenchmarkTools

julia&gt; @benchmark match(term,&quot;(1+2)/5&quot;)
BenchmarkTools.Trial:
  memory estimate:  2.17 KiB
  allocs estimate:  42
  --------------
  minimum time:     3.124 μs (0.00% GC)
  median time:      3.293 μs (0.00% GC)
  mean time:        3.655 μs (7.27% GC)
  maximum time:     1.348 ms (99.40% GC)
  --------------
  samples:          10000
  evals/sample:     8</code></pre><p>compared to Julia </p><pre><code class="language-julia">@benchmark Meta.parse(&quot;(1+2)/5&quot;)</code></pre><pre><code class="language-none">BenchmarkTools.Trial: 
  memory estimate:  496 bytes
  allocs estimate:  11
  --------------
  minimum time:     57.712 μs (0.00% GC)
  median time:      59.344 μs (0.00% GC)
  mean time:        64.961 μs (0.00% GC)
  maximum time:     2.292 ms (0.00% GC)
  --------------
  samples:          10000
  evals/sample:     1</code></pre><p>Parsing and transforming (here <code>eval</code>)</p><pre><code class="language-julia">@benchmark term(&quot;(1+2)/5&quot;)</code></pre><pre><code class="language-none">BenchmarkTools.Trial: 
  memory estimate:  8.92 KiB
  allocs estimate:  168
  --------------
  minimum time:     145.350 μs (0.00% GC)
  median time:      150.685 μs (0.00% GC)
  mean time:        167.992 μs (1.26% GC)
  maximum time:     10.835 ms (97.51% GC)
  --------------
  samples:          10000
  evals/sample:     1</code></pre><p>compared to Julia </p><pre><code class="language-julia">@benchmark eval(Meta.parse(&quot;(1+2)/5&quot;))</code></pre><pre><code class="language-none">BenchmarkTools.Trial: 
  memory estimate:  3.02 KiB
  allocs estimate:  49
  --------------
  minimum time:     135.104 μs (0.00% GC)
  median time:      138.791 μs (0.00% GC)
  mean time:        152.697 μs (0.00% GC)
  maximum time:     2.105 ms (0.00% GC)
  --------------
  samples:          10000
  evals/sample:     1</code></pre><h1 id="Acknowledgements"><a class="docs-heading-anchor" href="#Acknowledgements">Acknowledgements</a><a id="Acknowledgements-1"></a><a class="docs-heading-anchor-permalink" href="#Acknowledgements" title="Permalink"></a></h1><p>I am thankful for contributions and inspiration from many great packages:</p><h2 id="[TextParse.jl](https://github.com/queryverse/TextParse.jl)"><a class="docs-heading-anchor" href="#[TextParse.jl](https://github.com/queryverse/TextParse.jl)"><a href="https://github.com/queryverse/TextParse.jl">TextParse.jl</a></a><a id="[TextParse.jl](https://github.com/queryverse/TextParse.jl)-1"></a><a class="docs-heading-anchor-permalink" href="#[TextParse.jl](https://github.com/queryverse/TextParse.jl)" title="Permalink"></a></h2><blockquote><p>A bunch of fast text parsing tools, used in CSV.jl</p></blockquote><p><code>CombinedParsers</code> composes with fast <a href="https://github.com/queryverse/TextParse.jl">TextParse.jl</a> both ways  because <code>CombinedParser &lt;: TextParse.AbstractToken</code> and by providing a method for <code>TextParse.tryparsenext</code>, (leveraging the supreme Julia compiler, type and package architecture).</p><ul><li>If you seek support with a dates parser example, please contact me.</li><li>If you seek support with a CSV example, please contact me (e.g. address text field parsing).</li></ul><article class="docstring"><header><a class="docstring-binding" id="Dates.tryparsenext" href="#Dates.tryparsenext"><code>Dates.tryparsenext</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">TextParse.tryparsenext(x::CombinedParser,str,i,till,opts=TextParse.default_opts)</code></pre><p>TextParse.jl integrates with CombinedParsers.jl both ways.</p><pre><code class="language-">DocTestFilters = r&quot;map\(.+\)&quot;</code></pre><pre><code class="language-julia-repl">
julia&gt; p = (&quot;Number:&quot; * Repeat(&#39; &#39;) * TextParse.Numeric(Int))[3]
🗄 Sequence |&gt; map(IndexAt(3))
├─ Number\:
├─ \ *  |&gt; Repeat
└─ &lt;Int64&gt;
::Int64

julia&gt; parse(p, &quot;Number:    42&quot;)
42

julia&gt; TextParse.tryparsenext(p, &quot;Number:    42&quot;)
(Nullable{Int64}(42), 14)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/1a0c84100260a804d27be1e0946eca8e931d1df4/src/textparse.jl#LL3-L28">source</a></section></article><h2 id="Inspirations"><a class="docs-heading-anchor" href="#Inspirations">Inspirations</a><a id="Inspirations-1"></a><a class="docs-heading-anchor-permalink" href="#Inspirations" title="Permalink"></a></h2><ul><li>The work was strongly inspired by the great Scala <a href="https://github.com/lihaoyi/fastparse">fastparse</a> package, and also the <a href="https://package.elm-lang.org/packages/elm/parser/latest/">elm parser</a>.</li><li><a href="https://github.com/JuliaData/Parsers.jl">Parsers.jl</a>, a collection of parsers for date and primitive types, inspired the <a href="lib/public/#Base.parse"><code>parse</code></a> methods.</li><li><a href="https://github.com/BioJulia/Automa.jl">Automa.jl</a>, a Julia package for text validation, parsing, and tokenizing based on state machine compiler.  The package compiles deterministic finite automata.  (Currently there is no inter-operation possible, because in <code>Automa</code> processing of parsed tokens is done with actions and UTF8 support is lacking).</li><li><a href="https://github.com/andrewcooke/ParserCombinator.jl">ParserCombinator.jl</a> was a great inspiration. Yet I decided for a new design with a focus on transformations and type inference with parametric types, instead of basing this work off <code>ParserCombinator</code>, written before 2016 (and fixed for Julia 1.0 in 2018). <code>CombinedParsers</code> integrates into the Julia 1.0 Iteration API, small <code>Union{Nothing,T} where T</code> types instead of using Nullables, compiler optimizations and generated functions. I want to provide benchmarks comparisons with <code>ParserCombinator.jl</code>.</li></ul><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><ul><li><a href="man/example-person/#What-is-Parsing?">What is Parsing?</a></li><ul><li><a href="man/example-person/#Names">Names</a></li><li><a href="man/example-person/#Addresses">Addresses</a></li><li><a href="man/example-person/#Person&#39;s-address-data">Person&#39;s address data</a></li></ul><li><a href="man/example-number-ranges/#Number-lists-(wikitext-references)">Number lists (wikitext references)</a></li><ul><li><a href="man/example-number-ranges/#Number-ranges">Number ranges</a></li><li><a href="man/example-number-ranges/#Numbers">Numbers</a></li><li><a href="man/example-number-ranges/#Joining-numbers-and-ranges">Joining numbers and ranges</a></li><li><a href="man/example-number-ranges/#Inclusion-in-a-wikitext-parser">Inclusion in a wikitext parser</a></li><li><a href="man/example-number-ranges/#PCRE-papercuts-when-parsing-number-sequences">PCRE papercuts when parsing number sequences</a></li></ul><li><a href="man/pcre/#Regular-Expressions-[CombinedParser](@ref)">Regular Expressions <code>CombinedParser</code></a></li><ul><li><a href="man/pcre/#What-is-a-regular-expression?">What is a regular expression?</a></li><li><a href="man/pcre/#Characters-and-Escaped-Characters">Characters and Escaped Characters</a></li><li><a href="man/pcre/#Repeated-patterns">Repeated patterns</a></li><ul><li><a href="man/pcre/#Number-of-Repetitions:-Transforming-a-Parsing">Number of Repetitions: Transforming a Parsing</a></li></ul><li><a href="man/pcre/#[Either](@ref)"><code>Either</code></a></li><li><a href="man/pcre/#Repeatable-patterns,-[Optional](@ref),-[Lazy](@ref)-and-[Atomic](@ref)">Repeatable patterns, <code>Optional</code>, <code>Lazy</code> and <code>Atomic</code></a></li><li><a href="man/pcre/#[Sequence](@ref)s-and-Alternations"><code>Sequence</code>s and Alternations</a></li><li><a href="man/pcre/#[Capture](@ref)s"><code>Capture</code>s</a></li><li><a href="man/pcre/#[Lookahead](@ref)-and-[Lookbehind](@ref)"><code>Lookahead</code> and <code>Lookbehind</code></a></li><li><a href="man/pcre/#Regular-Expression-Brackets">Regular Expression Brackets</a></li></ul><li><a href="man/example-palindromes/#Palindromes:CombinedParser:-a-Tutorial-for-writing-your-combinable-Parser"><code>Palindromes&lt;:CombinedParser</code>: a Tutorial for writing your combinable Parser</a></li><ul><li><a href="man/example-palindromes/#.-Regular-Expression">1. Regular Expression</a></li><ul><li><a href="man/example-palindromes/#Tree-display-of-regex">Tree display of regex</a></li><li><a href="man/example-palindromes/#Regular-Expression-performance">Regular Expression performance</a></li></ul><li><a href="man/example-palindromes/#.-A-non-word-skipping-Palindrome:CombinedParser">2. A non-word skipping <code>Palindrome&lt;:CombinedParser</code></a></li><ul><li><a href="man/example-palindromes/#Parsing-strategy">Parsing strategy</a></li><ul><li><a href="man/example-palindromes/#Prerequisite:-Skipping-whitespace">Prerequisite: Skipping whitespace</a></li></ul><li><a href="man/example-palindromes/#Subtyping-:-CombinedParser{STATE,RESULT}.">Subtyping <code>&lt;: CombinedParser{STATE,RESULT}</code>.</a></li><li><a href="man/example-palindromes/#Matching:-CombinedParsers._iterate">Matching: <code>CombinedParsers._iterate</code></a></li><li><a href="man/example-palindromes/#Base.prevind-and-Base.nextind"><code>Base.prevind</code> and <code>Base.nextind</code></a></li><li><a href="man/example-palindromes/#match-and-get"><code>match</code> and <code>get</code></a></li><li><a href="man/example-palindromes/#Iterating-through-matches">Iterating through matches</a></li><ul><li><a href="man/example-palindromes/#Iteration-of-smaller-Sub-palindromes">Iteration of smaller Sub-palindromes</a></li></ul><li><a href="man/example-palindromes/#Performance-Optimization">Performance Optimization</a></li><li><a href="man/example-palindromes/#Padding-and-combining">Padding and combining</a></li></ul><li><a href="man/example-palindromes/#Next...">Next...</a></li></ul><li><a href="man/json/#JSON">JSON</a></li></ul><h1 id="Library-Outline"><a class="docs-heading-anchor" href="#Library-Outline">Library Outline</a><a id="Library-Outline-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Outline" title="Permalink"></a></h1><ul><li><a href="lib/public/#Public-Documentation">Public Documentation</a></li><ul><li><a href="lib/public/#Matching">Matching</a></li><ul><li><a href="lib/public/#Parsing">Parsing</a></li></ul><li><a href="lib/public/#Typed-Transformation-Parsers">Typed Transformation Parsers</a></li><li><a href="lib/public/#Parser-Constructors">Parser Constructors</a></li><ul><li><a href="lib/public/#useful-importable-sub-parsers">useful importable sub-parsers</a></li><li><a href="lib/public/#Character-Matchers">Character Matchers</a></li><li><a href="lib/public/#Combining-Parser">Combining Parser</a></li><li><a href="lib/public/#Repeating">Repeating</a></li><li><a href="lib/public/#Logging-and-Side-Effects">Logging and Side-Effects</a></li><li><a href="lib/public/#Assertions">Assertions</a></li></ul></ul><li><a href="lib/internals/#Internal-API">Internal API</a></li><ul><li><a href="lib/internals/#Iterating-Parsings">Iterating Parsings</a></li></ul><li><a href="lib/internals/#Internal-Types">Internal Types</a></li><ul><li><a href="lib/internals/#Abstract-Parsers">Abstract Parsers</a></li><li><a href="lib/internals/#Wrapped-Parsers">Wrapped Parsers</a></li><li><a href="lib/internals/#States">States</a></li><li><a href="lib/internals/#Printing">Printing</a></li><li><a href="lib/internals/#Rewriting-Parsers">Rewriting Parsers</a></li></ul></ul><h3 id="main-index"><a class="docs-heading-anchor" href="#main-index">Index</a><a id="main-index-1"></a><a class="docs-heading-anchor-permalink" href="#main-index" title="Permalink"></a></h3><ul><li><a href="lib/public/#CombinedParsers.Lookahead"><code>CombinedParsers.Lookahead</code></a></li><li><a href="lib/public/#CombinedParsers.Lookbehind"><code>CombinedParsers.Lookbehind</code></a></li><li><a href="lib/public/#CombinedParsers.Repeat1"><code>CombinedParsers.Repeat1</code></a></li><li><a href="lib/public/#CombinedParsers.Repeat_stop"><code>CombinedParsers.Repeat_stop</code></a></li><li><a href="lib/public/#CombinedParsers.Repeat_until"><code>CombinedParsers.Repeat_until</code></a></li><li><a href="lib/public/#CombinedParsers.either_types"><code>CombinedParsers.either_types</code></a></li><li><a href="lib/public/#CombinedParsers.log_names"><code>CombinedParsers.log_names</code></a></li><li><a href="lib/public/#CombinedParsers.map_at"><code>CombinedParsers.map_at</code></a></li><li><a href="lib/public/#CombinedParsers.parser"><code>CombinedParsers.parser</code></a></li><li><a href="lib/public/#CombinedParsers.result_type"><code>CombinedParsers.result_type</code></a></li><li><a href="lib/public/#CombinedParsers.sEither"><code>CombinedParsers.sEither</code></a></li><li><a href="lib/public/#CombinedParsers.sSequence"><code>CombinedParsers.sSequence</code></a></li><li><a href="lib/public/#CombinedParsers.state_type"><code>CombinedParsers.state_type</code></a></li><li><a href="lib/public/#CombinedParsers.tryparse_pos"><code>CombinedParsers.tryparse_pos</code></a></li><li><a href="lib/public/#CombinedParsers.with_effect"><code>CombinedParsers.with_effect</code></a></li><li><a href="lib/public/#CombinedParsers.with_log"><code>CombinedParsers.with_log</code></a></li><li><a href="lib/public/#CombinedParsers.with_name"><code>CombinedParsers.with_name</code></a></li><li><a href="lib/public/#CombinedParsers.Always"><code>CombinedParsers.Always</code></a></li><li><a href="lib/public/#CombinedParsers.AnyChar"><code>CombinedParsers.AnyChar</code></a></li><li><a href="lib/public/#CombinedParsers.AtEnd"><code>CombinedParsers.AtEnd</code></a></li><li><a href="lib/public/#CombinedParsers.AtStart"><code>CombinedParsers.AtStart</code></a></li><li><a href="lib/public/#CombinedParsers.Atomic"><code>CombinedParsers.Atomic</code></a></li><li><a href="lib/public/#CombinedParsers.CharIn"><code>CombinedParsers.CharIn</code></a></li><li><a href="lib/public/#CombinedParsers.CharNotIn"><code>CombinedParsers.CharNotIn</code></a></li><li><a href="lib/public/#CombinedParsers.Constant"><code>CombinedParsers.Constant</code></a></li><li><a href="lib/public/#CombinedParsers.Either"><code>CombinedParsers.Either</code></a></li><li><a href="lib/public/#CombinedParsers.JoinSubstring"><code>CombinedParsers.JoinSubstring</code></a></li><li><a href="lib/public/#CombinedParsers.Lazy"><code>CombinedParsers.Lazy</code></a></li><li><a href="lib/public/#CombinedParsers.MatchesIterator"><code>CombinedParsers.MatchesIterator</code></a></li><li><a href="lib/public/#CombinedParsers.NegativeLookahead"><code>CombinedParsers.NegativeLookahead</code></a></li><li><a href="lib/public/#CombinedParsers.NegativeLookbehind"><code>CombinedParsers.NegativeLookbehind</code></a></li><li><a href="lib/public/#CombinedParsers.Never"><code>CombinedParsers.Never</code></a></li><li><a href="lib/public/#CombinedParsers.Optional"><code>CombinedParsers.Optional</code></a></li><li><a href="lib/public/#CombinedParsers.ParseMatch"><code>CombinedParsers.ParseMatch</code></a></li><li><a href="lib/public/#CombinedParsers.PositiveLookahead"><code>CombinedParsers.PositiveLookahead</code></a></li><li><a href="lib/public/#CombinedParsers.PositiveLookbehind"><code>CombinedParsers.PositiveLookbehind</code></a></li><li><a href="lib/public/#CombinedParsers.Repeat"><code>CombinedParsers.Repeat</code></a></li><li><a href="lib/public/#CombinedParsers.Sequence"><code>CombinedParsers.Sequence</code></a></li><li><a href="lib/public/#CombinedParsers.Regexp.integer_base"><code>CombinedParsers.Regexp.integer_base</code></a></li><li><a href="lib/internals/#CombinedParsers._ismatch"><code>CombinedParsers._ismatch</code></a></li><li><a href="lib/internals/#CombinedParsers._iterate"><code>CombinedParsers._iterate</code></a></li><li><a href="lib/internals/#CombinedParsers.deepmap_parser"><code>CombinedParsers.deepmap_parser</code></a></li><li><a href="lib/internals/#CombinedParsers.ismatch"><code>CombinedParsers.ismatch</code></a></li><li><a href="lib/internals/#CombinedParsers.print_constructor"><code>CombinedParsers.print_constructor</code></a></li><li><a href="lib/internals/#CombinedParsers.regex_inner"><code>CombinedParsers.regex_inner</code></a></li><li><a href="lib/internals/#CombinedParsers.regex_prefix"><code>CombinedParsers.regex_prefix</code></a></li><li><a href="lib/internals/#CombinedParsers.regex_string"><code>CombinedParsers.regex_string</code></a></li><li><a href="lib/internals/#CombinedParsers.regex_suffix"><code>CombinedParsers.regex_suffix</code></a></li><li><a href="lib/internals/#CombinedParsers.tuple_pos"><code>CombinedParsers.tuple_pos</code></a></li><li><a href="lib/internals/#CombinedParsers.tuple_state"><code>CombinedParsers.tuple_state</code></a></li><li><a href="lib/internals/#CombinedParsers.CombinedParser"><code>CombinedParsers.CombinedParser</code></a></li><li><a href="lib/internals/#CombinedParsers.ConstantParser"><code>CombinedParsers.ConstantParser</code></a></li><li><a href="lib/internals/#CombinedParsers.FilterParser"><code>CombinedParsers.FilterParser</code></a></li><li><a href="lib/internals/#CombinedParsers.LeafParser"><code>CombinedParsers.LeafParser</code></a></li><li><a href="lib/internals/#CombinedParsers.LookAround"><code>CombinedParsers.LookAround</code></a></li><li><a href="lib/internals/#CombinedParsers.MatchState"><code>CombinedParsers.MatchState</code></a></li><li><a href="lib/internals/#CombinedParsers.MemoTreeChildren"><code>CombinedParsers.MemoTreeChildren</code></a></li><li><a href="lib/internals/#CombinedParsers.NCodeunitsState"><code>CombinedParsers.NCodeunitsState</code></a></li><li><a href="lib/internals/#CombinedParsers.NIndexParser"><code>CombinedParsers.NIndexParser</code></a></li><li><a href="lib/internals/#CombinedParsers.None"><code>CombinedParsers.None</code></a></li><li><a href="lib/internals/#CombinedParsers.Transformation"><code>CombinedParsers.Transformation</code></a></li><li><a href="lib/internals/#CombinedParsers.WrappedParser"><code>CombinedParsers.WrappedParser</code></a></li><li><a href="lib/internals/#CombinedParsers.Regexp.NoDict"><code>CombinedParsers.Regexp.NoDict</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="man/guide/">Overview »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 1 July 2020 23:11">Wednesday 1 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
